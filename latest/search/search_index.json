{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vivified Platform","text":""},{"location":"#enterprise-application-kernel-with-plugin-architecture","title":"Enterprise application kernel with plugin architecture","text":"<p>Vivified is a modular platform for building secure, scalable applications. Deploy anything from ERP systems to security operations centers, messaging hubs to compliance platforms.</p> <ul> <li> <p>:material-book-open:{ .lg .middle } Getting Started</p> <p>Set up Vivified locally in 5 minutes</p> <p>:octicons-arrow-right-24: Quick start</p> </li> <li> <p>:material-puzzle:{ .lg .middle } Plugin Development</p> <p>Build and deploy custom plugins</p> <p>:octicons-arrow-right-24: Plugin SDK</p> </li> <li> <p>:material-api:{ .lg .middle } API Reference</p> <p>REST, WebSocket, and RPC documentation</p> <p>:octicons-arrow-right-24: API docs</p> </li> <li> <p>:material-server:{ .lg .middle } Deployment</p> <p>Production deployment guides</p> <p>:octicons-arrow-right-24: Deploy</p> </li> </ul>"},{"location":"#platform-overview","title":"Platform Overview","text":"<p>Vivified provides a secure foundation for enterprise applications through its three-lane communication model and trait-based access control (TBAC).</p>"},{"location":"#architecture","title":"Architecture","text":"<p>```mermaid graph TB     subgraph \"Applications\"         APP1[ERP System]         APP2[Security Platform]         APP3[Messaging Hub]         APP4[Custom Application]     end</p> <pre><code>subgraph \"Core Platform\"\n    GW[Gateway]\n    AUTH[Identity &amp; TBAC]\n    POL[Policy Engine]\n    STOR[Storage Service]\n    MSG[Message Bus]\n    AUDIT[Audit Service]\nend\n\nsubgraph \"Plugins\"\n    P1[Splunk Integration]\n    P2[Slack/Teams]\n    P3[Database Connectors]\n    P4[Custom Plugins]\nend\n\nAPP1 --&gt; GW\nAPP2 --&gt; GW\nAPP3 --&gt; GW\nAPP4 --&gt; GW\n\nGW --&gt; AUTH\nAUTH --&gt; POL\nGW --&gt; MSG\nMSG --&gt; P1\nMSG --&gt; P2\nMSG --&gt; P3\nMSG --&gt; P4\n</code></pre> <p>```</p>"},{"location":"#use-cases","title":"Use Cases","text":"Enterprise OperationsSecurity OperationsHealthcare &amp; Compliance <p>ERP for SMB - Inventory management plugins - Financial processing - HR workflows - Custom reporting</p> <p>Messaging Nerve Center - Route faxes to Slack/Teams - Push notifications via Pushover - Email-to-SMS bridges - Trait-based routing (no manual lists)</p> <p>Red Team/Blue Team Platform - Splunk integration - Custom SIEM from your SOC - Aircrack-ng automation - Vulnerability scanning orchestration</p> <p>Compliance &amp; Audit - Automated compliance checks - Audit trail aggregation - Policy enforcement - Report generation</p> <p>HIPAA-Compliant Systems - Patient data management - Clinical workflows - Insurance processing - Regulatory reporting</p> <p>Financial Services - Transaction processing - Risk assessment - Regulatory compliance - Audit requirements</p>"},{"location":"#core-features","title":"Core Features","text":"Feature Description Use Case Trait-Based Access Control Dynamic permission system based on user/service traits No manual ACL maintenance Three-Lane Communication Canonical events, RPC operations, proxied external calls Clean plugin isolation Plugin Architecture Hot-loadable plugins with sandboxing Extend without modifying core Audit Service Comprehensive audit logging with configurable retention Compliance and debugging Policy Engine Declarative policies for access control Fine-grained permissions Storage Abstraction Pluggable storage backends Use existing infrastructure"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Architecture \u2192 Three-Lane Model</li> <li>Architecture \u2192 Diagrams</li> <li>AI &amp; Agents \u2192 Overview</li> </ul>"},{"location":"#defaults","title":"Defaults","text":"<ul> <li>Database: Postgres (<code>postgresql+asyncpg://\u2026</code>) for non\u2011test runs; tests default to in\u2011memory SQLite unless <code>TEST_DB_URL</code> overrides</li> <li>RAG (AI): Redis (<code>redis://localhost:6379/0</code>) by default with graceful fallback to in\u2011memory</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>docker-compose up -d\ncurl http://localhost:8080/health\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Language Support</p> <p>Both Python and Node.js SDKs provide identical functionality. Choose based on your existing stack.</p>"},{"location":"#plugin-example","title":"Plugin Example","text":"PythonNode.jsConfiguration <pre><code>from vivified import Plugin, canonical, operator\n\nclass IntegrationPlugin(Plugin):\n    \"\"\"Example integration plugin\"\"\"\n\n    @canonical.subscribe(\"document.received\")\n    async def handle_document(self, event):\n        # Route based on traits\n        recipients = await self.identity.find_by_traits(\n            [\"department:finance\", \"notify:documents\"]\n        )\n\n        for recipient in recipients:\n            await self.send_notification(recipient, event.data)\n\n    @operator.expose(\"send_notification\")\n    async def send_notification(self, recipient, data):\n        # Send via configured channel\n        channel = recipient.traits.get(\"preferred_channel\", \"email\")\n        return await self.channels[channel].send(recipient, data)\n</code></pre> <pre><code>import { Plugin, canonical, operator } from '@vivified/sdk';\n\nclass IntegrationPlugin extends Plugin {\n  @canonical.subscribe('document.received')\n  async handleDocument(event) {\n    // Route based on traits\n    const recipients = await this.identity.findByTraits([\n      'department:finance',\n      'notify:documents'\n    ]);\n\n    for (const recipient of recipients) {\n      await this.sendNotification(recipient, event.data);\n    }\n  }\n\n  @operator.expose('sendNotification')\n  async sendNotification(recipient, data) {\n    // Send via configured channel\n    const channel = recipient.traits.preferredChannel || 'email';\n    return await this.channels[channel].send(recipient, data);\n  }\n}\n</code></pre> <pre><code># plugin.yaml\nname: integration-plugin\nversion: 1.0.0\ntraits:\n  - can_send_notifications\n  - can_access_user_directory\nchannels:\n  email:\n    provider: smtp\n    host: mail.example.com\n  slack:\n    webhook_url: ${SLACK_WEBHOOK}\n  pushover:\n    app_token: ${PUSHOVER_TOKEN}\n</code></pre>"},{"location":"#communication-patterns","title":"Communication Patterns","text":"Three-Lane Model <p>Canonical Lane - Event-driven messaging - Asynchronous processing - Event sourcing patterns - Loose coupling between services</p> <p>Operator Lane - Synchronous RPC - Direct method invocation - Request/response patterns - Strong typing support</p> <p>Proxy Lane - External API access - Controlled external communication - Rate limiting and retry logic - Credential management</p>"},{"location":"#quick-start_1","title":"Quick Start","text":""},{"location":"#local-development","title":"Local Development","text":"<pre><code># Clone repository\ngit clone https://github.com/DMontgomery40/vivified.git\ncd vivified\n\n# Start services\ndocker-compose up -d\n\n# Verify health\ncurl http://localhost:8080/health\n\n# View logs\ndocker-compose logs -f\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Environment Variables</p> <p>See <code>.env.example</code> for all configuration options</p> Variable Description Default <code>GATEWAY_PORT</code> API gateway port <code>8080</code> <code>DATABASE_URL</code> PostgreSQL connection string <code>postgresql+asyncpg://vivified:changeme@localhost:5432/vivified</code> <code>REDIS_URL</code> Redis connection for RAG (default) <code>redis://localhost:6379/0</code> <code>LOG_LEVEL</code> Logging verbosity <code>info</code> <code>PLUGIN_DIR</code> Plugin directory path <code>./plugins</code>"},{"location":"#production-deployment","title":"Production Deployment","text":"KubernetesDocker SwarmAWS ECS <pre><code># vivified-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: vivified-core\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: vivified\n  template:\n    metadata:\n      labels:\n        app: vivified\n    spec:\n      containers:\n      - name: vivified\n        image: vivified/core:latest\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: vivified-secrets\n              key: database-url\n</code></pre> <pre><code># docker-stack.yml\nversion: '3.8'\nservices:\n  vivified:\n    image: vivified/core:latest\n    deploy:\n      replicas: 3\n      update_config:\n        parallelism: 1\n        delay: 10s\n    environment:\n      DATABASE_URL: ${DATABASE_URL}\n</code></pre> <pre><code>{\n  \"family\": \"vivified\",\n  \"taskDefinition\": {\n    \"containerDefinitions\": [{\n      \"name\": \"vivified-core\",\n      \"image\": \"vivified/core:latest\",\n      \"memory\": 2048,\n      \"cpu\": 1024,\n      \"essential\": true\n    }]\n  }\n}\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Core Services - Gateway, Identity, Policy, Storage</li> <li>Plugin Development - SDK reference and examples</li> <li>Admin Console - Web-based management interface</li> <li>API Reference - REST, WebSocket, and RPC APIs</li> <li>Deployment Guide - Production deployment</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Issues - Bug reports and feature requests</li> <li>Discussions - Questions and community support</li> <li>Contributing - Contribution guidelines</li> </ul> <p>MIT License | GitHub</p>"},{"location":"admin-console/","title":"Overview","text":"<ul> <li> <p>:material-dashboard:{ .lg .middle } Admin Console</p> <p>Single-pane management for all platform features, accessible and dyslexia-friendly</p> </li> <li> <p>:material-plugin:{ .lg .middle } Plugin Marketplace</p> <p>Browse, install, and configure plugins from the console</p> </li> <li> <p>:material-settings:{ .lg .middle } Configuration Center</p> <p>Manage environment variables, retention policies, and system settings</p> </li> </ul> <p>!!! tip 'User Experience'     The Admin Console uses readable fonts, high-contrast themes, and keyboard-first navigation for better usability.</p> <p>!!! note 'Admin-first requirement'     Everything available via CLI must have an equivalent or better experience in the Admin Console.</p> <p>!!! warning 'Permissions'     Admin Console actions are controlled by RBAC. Users without sufficient roles will not see certain actions.</p>"},{"location":"admin-console/#key-screens","title":"Key screens","text":"Screen Purpose Access Dashboard Health, metrics, quick actions admin Plugins Marketplace &amp; registrations admin Storage Browser Browse classified objects admin/storage Policy Inspector Review routing and filter rules admin/policy <ul> <li> <p>:material-search:{ .lg .middle } Search &amp; Filter</p> <p>Global search across users, plugins, and audit logs</p> </li> <li> <p>:material-visibility:{ .lg .middle } Audit Explorer</p> <p>View and export audit trails for compliance</p> </li> </ul>"},{"location":"admin-console/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"<ul> <li>Ctrl+K \u2014 open command palette</li> <li>Ctrl+F \u2014 focus search</li> <li>Esc \u2014 close modals</li> </ul>"},{"location":"admin-console/#building-admin-ui-locally","title":"Building Admin UI locally","text":"Node.jsMakeDocker <pre><code># Build the Admin UI locally\ncd core/admin_ui\nnpm ci\nnpm run build\n# Build artifacts will be in core/admin_ui/build/\n</code></pre> <pre><code># Using the Makefile (recommended)\nmake ui-ci-local\n# This builds both core/ui and core/admin_ui\n</code></pre> <pre><code># Build with Docker\ndocker build -f core/admin_ui/Dockerfile -t vivified-admin-ui .\n</code></pre> <p>The Admin Console is packaged as a Single Page Application (SPA) and served under <code>/admin/ui</code>. In production, ensure UI build artifacts are available by running the build process during deployment.</p> <p><code>mermaid graph LR   AdminUser --&gt; Browser   Browser --&gt;|HTTPS| AdminConsole   AdminConsole --&gt; AdminAPI   AdminAPI --&gt; CoreServices</code></p>"},{"location":"admin-console/#settings-and-configuration","title":"Settings and configuration","text":"Setting Purpose Where to edit Notes THEME UI theme (default/high contrast) Settings &gt; Appearance Visual preference RETENTION_YEARS Default PHI retention Settings &gt; Storage Overrides per plugin allowed PLUGIN_APPROVAL Require approval for plugin install Settings &gt; Plugins Recommended for prod <p>!!! note 'Audit for UI actions'     Every UI change emits an audit event (actor, action, target). Use Audit Explorer to trace actions.</p> <p>??? note 'Advanced: embedding widgets'     Plugins can register Admin UI widgets via the manifest and a JS entrypoint. Follow the UI component style guide in core/ui.</p>"},{"location":"api-reference/","title":"REST API","text":"<ul> <li> <p>:material-api:{ .lg .middle } Admin API</p> <p>Role-based endpoints for system management and plugin operations</p> </li> <li> <p>:material-account-box:{ .lg .middle } User &amp; Role Management</p> <p>CRUD for users, roles, and assignments</p> </li> <li> <p>:material-cloud-upload:{ .lg .middle } Plugin &amp; Config API</p> <p>Register plugins, query audits, and manage configuration via API</p> </li> </ul> <p>!!! tip 'Use role-scoped tokens'     Create service tokens with minimal scopes for automation and integrations.</p> <p>!!! note 'Rate limits'     Admin API enforces per-client rate-limits managed via the gateway configuration.</p> <p>!!! warning 'Audit queries may be large'     Use pagination and filters when querying audit logs to avoid long-running requests.</p>"},{"location":"api-reference/#common-endpoints","title":"Common endpoints","text":"Endpoint Purpose Method Auth /api/users Manage users GET/POST/PUT/DELETE admin /api/plugins Register/list plugins GET/POST admin /api/config Read/update config GET/PUT admin /api/audit Query audit logs GET admin/audit"},{"location":"api-reference/#example-create-a-user","title":"Example: Create a user","text":"PythonNode.jscurl <pre><code># (1)\nimport requests\ntoken = 'Bearer &lt;ADMIN_TOKEN&gt;'\nr = requests.post('https://admin.example/api/users', headers={'Authorization': token}, json={'username':'alice'})\nprint(r.json())\n</code></pre> <pre><code>// (1)\nconst fetch = require('node-fetch')\nconst res = await fetch('https://admin.example/api/users', { method: 'POST', headers: { Authorization: 'Bearer &lt;ADMIN_TOKEN&gt;', 'Content-Type': 'application/json' }, body: JSON.stringify({ username: 'alice' }) })\nconsole.log(await res.json())\n</code></pre> <pre><code># (1)\ncurl -X POST https://admin.example/api/users -H 'Authorization: Bearer &lt;ADMIN_TOKEN&gt;' -H 'Content-Type: application/json' -d '{\"username\":\"alice\"}'\n</code></pre> <ol> <li>Use scoped tokens and role assertions; avoid admin tokens in automation when possible</li> </ol> <p><code>mermaid graph LR   AdminUI --&gt;|API Calls| API   API --&gt; AuthService   API --&gt; Storage   API --&gt; Plugins   API --&gt; Audit</code></p>"},{"location":"api-reference/#audit-api-filtering","title":"Audit API: filtering","text":"Filter Description Example actor Who performed action actor=system or user id action Action type create,user.update since ISO datetime 2024-01-01T00:00:00Z <p>!!! note 'Pagination'     The Admin API uses cursor-based pagination for large datasets. Check response for ++next_cursor++ field.</p> <p>??? note 'Advanced: webhook integrations'     The Admin API supports webhook delivery for events. Use signed payloads and retry policies.</p> <ol> <li> <p>API access is audited and role-checked. Ensure service accounts are limited in scope and rotated regularly.\u00a0\u21a9</p> </li> </ol>"},{"location":"backup/","title":"Backup &amp; Recovery","text":"<p>Backup guidance for database and object storage. Include retention and restore playbooks.</p>"},{"location":"configuration/","title":"Configuration","text":"<ul> <li> <p>:material-settings:{ .lg .middle } Configuration Reference</p> <p>Centralized environment and configuration keys for the Vivified platform</p> </li> <li> <p>:material-tune:{ .lg .middle } Per-service settings</p> <p>Config keys for canonical, storage, messaging, gateway, and API</p> </li> <li> <p>:material-history:{ .lg .middle } Retention &amp; Compliance</p> <p>All retention-related keys and defaults</p> </li> </ul> <p>!!! tip 'Centralized management'     Configure production keys via the Admin Console or your secrets manager; do not store secrets in repo or plain text.</p> <p>!!! note 'Structure'     Use environment variables for runtime-only settings and persisted config for tunable platform behavior.</p> <p>!!! warning 'Config drift'     Ensure configuration is consistent across environments: mismatched retention or key settings may cause compliance gaps.</p>"},{"location":"configuration/#global-configuration-table-complete","title":"Global configuration table (complete)","text":"Key Service Purpose Example Required APP_ENV global Environment name production yes DATABASE_URL api/storage DB connection string postgresql://... yes STORAGE_BACKEND storage Storage backend type s3 yes STORAGE_KMS_KEY storage KMS key id arn:aws:kms:... yes RETENTION_YEARS storage Default PHI retention (years) 7 yes AUDIT_RETENTION_YEARS audit Audit retention 7 recommended BUS_BACKEND messaging Messaging backend type kafka yes GATEWAY_RATE_LIMIT gateway Per-client rate limit 100/min recommended GATEWAY_AUTH_TYPE gateway Auth mode (jwt/mTLS) jwt yes LOG_LEVEL global Logging verbosity INFO recommended UI_BUILD_ASSETS admin-ui Path to UI assets /var/www/admin_ui recommended"},{"location":"configuration/#examples-environment-snippets","title":"Examples: environment snippets","text":"PythonNode.jscurl <pre><code># (1)\n# Example: load configuration using pydantic BaseSettings\nfrom pydantic import BaseSettings\nclass Settings(BaseSettings):\n    app_env: str\n    database_url: str\n    class Config:\n        env_file = '.env'\n</code></pre> <pre><code>// (1)\n// Example: load config via process.env\nconst config = {\n  dbUrl: process.env.DATABASE_URL,\n  storageBackend: process.env.STORAGE_BACKEND || 's3'\n}\n</code></pre> <pre><code># (1)\nexport APP_ENV=development\n# Prefer Postgres by default\nexport DATABASE_URL='postgresql+asyncpg://vivified:changeme@localhost:5432/vivified'\n# RAG uses Redis by default when available\nexport REDIS_URL='redis://localhost:6379/0'\n# Tests remain hermetic unless TEST_DB_URL overrides\n# export TEST_DB_URL='sqlite+aiosqlite:///:memory:'\n</code></pre> <ol> <li>Prefer a secrets manager for production KMS and DB credentials</li> </ol> <p><code>mermaid graph LR   Env[Environment Vars] --&gt; App   ConfigStore --&gt; App   App --&gt; Services   Services --&gt; Audit</code></p>"},{"location":"configuration/#per-service-configuration-comparisons","title":"Per-service configuration comparisons","text":"Setting Canonical Storage Messaging Gateway retention schema versioning retention years retention days rate limits encryption N/A envelope AES-256 &amp; KMS message-level encryption TLS &amp; validation audit transform audits access &amp; change logs message audit request audit <p>!!! note 'Versioning &amp; migrations'     For config fields that are schema-related, use versioned keys and migration tooling. Avoid in-place changes without migrations.</p> <p>??? note 'Advanced: dynamic flags'     Some flags may be toggled at runtime via the Admin Console; use feature flags for experimental behavior.</p> <ol> <li> <p>Keep production configuration under strict access controls and ensure audit trails for changes.\u00a0\u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Contribution guidelines, coding standards, and CI expectations. Run <code>make ci-local</code> before pushing.</p>"},{"location":"deployment/","title":"Deployment","text":"<p>Docker Compose for local dev; Kubernetes manifests provided under <code>k8s/</code>. Production guidance will be expanded here.</p>"},{"location":"getting-started-material/","title":"Getting Started with Vivified Platform","text":"<p>Welcome to the Vivified platform! This guide will help you get up and running with our HIPAA-compliant healthcare platform, designed with a plugin-based architecture and Docker-based deployment.</p>"},{"location":"getting-started-material/#quick-links","title":"Quick Links","text":"<ul> <li>:gear: Installation Guide   Learn how to set up Vivified on your system.</li> <li>:computer: SDKs   Explore our Python and Node.js SDKs.</li> <li>:cloud: REST API   Dive into our API for robust integrations.</li> <li>:lock: Security   Understand our HIPAA-compliant architecture.</li> <li>:book: Documentation   Access all platform resources.</li> </ul>"},{"location":"getting-started-material/#installation-guide","title":"Installation Guide","text":"<p>Note</p> <p>This section will guide you through the basic installation steps for the Vivified platform.</p>"},{"location":"getting-started-material/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker and Docker Compose</li> <li>Access to Vivified's private repository</li> </ul>"},{"location":"getting-started-material/#step-by-step-installation","title":"Step-by-Step Installation","text":"<ol> <li>Clone the Repository</li> </ol> <pre><code>git clone https://github.com/vivified/vivified-platform.git\ncd vivified-platform\n</code></pre> <ol> <li>Start Docker Services</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Verify Installation</li> </ol> <p>Access the platform at <code>http://localhost:8000</code>.</p> Advanced Configuration <p>For advanced configuration options, please refer to the Configuration Table below.</p>"},{"location":"getting-started-material/#sdks","title":"SDKs","text":"<p>Vivified provides SDKs for both Python and Node.js to facilitate easy integration.</p> PythonNode.jscurl <pre><code>from vivified_sdk import Client\n\nclient = Client(api_key=\"your_api_key\")\nresponse = client.get_patient_data(patient_id=\"12345\")\nprint(response)\n</code></pre> <pre><code>const { Client } = require('vivified-sdk');\n\nconst client = new Client('your_api_key');\nclient.getPatientData('12345').then(response =&gt; {\n  console.log(response);\n});\n</code></pre> <pre><code>curl -X GET \"https://api.vivified.com/patients/12345\" -H \"Authorization: Bearer your_api_key\"\n</code></pre> <p>Tip</p> <p>Make sure to replace <code>your_api_key</code> with your actual API key obtained from the Vivified dashboard.</p>"},{"location":"getting-started-material/#rest-api","title":"REST API","text":"<p>The Vivified REST API provides endpoints for managing healthcare data.</p>"},{"location":"getting-started-material/#authentication","title":"Authentication","text":"<p>All requests must include an <code>Authorization</code> header with a valid API key.</p> <pre><code>Authorization: Bearer your_api_key\n</code></pre>"},{"location":"getting-started-material/#configuration-table","title":"Configuration Table","text":"Parameter Description Default Value <code>API_PORT</code> Port for API server <code>8000</code> <code>DB_HOST</code> Database host address <code>localhost</code> <code>DB_PORT</code> Database port <code>5432</code> <code>LOG_LEVEL</code> Level of logging (info, debug) <code>info</code>"},{"location":"getting-started-material/#architecture","title":"Architecture","text":"<p>Below is a visual representation of Vivified's architecture.</p> <p><code>mermaid graph TD;     A[User] --&gt;|requests| B[API Gateway];     B --&gt; C[Authentication Service];     B --&gt; D[Data Service];     D --&gt; E[Database];     C --&gt; F[HIPAA Compliance Layer];</code></p> <p>Warning</p> <p>Ensure all components are properly configured to maintain HIPAA compliance.</p>"},{"location":"getting-started-material/#security","title":"Security","text":"<p>Vivified is designed with security at its core, ensuring all data handling complies with HIPAA regulations.</p> <p>Danger</p> <p>Unauthorized access to healthcare data is strictly prohibited and could lead to severe penalties.</p> Further Reading <p>For more details on our security measures, visit our Security Documentation.</p>"},{"location":"getting-started-material/#documentation","title":"Documentation","text":"<p>For more detailed information, visit the Vivified Documentation.</p> <p>With this guide, you should be well-equipped to start using the Vivified platform. If you encounter any issues, please reach out to our support team. Happy coding!</p>"},{"location":"getting-started/","title":"Quick Start","text":"<ul> <li> <p>:material-rocket:{ .lg .middle } Quick Start</p> <p>Get up and running with Vivified in minutes \u2014 Local CI, Admin Console, and Plugin onboarding</p> </li> <li> <p>:material-account-circle:{ .lg .middle } Admin First</p> <p>All features accessible from the Admin Console; accessibility-first UI</p> </li> <li> <p>:material-automatic:{ .lg .middle } CI Parity</p> <p>Run exactly what CI runs locally to avoid surprise failures</p> </li> </ul> <p>!!! tip 'Best Practice'     Always run the Local CI Parity preflight before pushing. Use Python 3.11 and the pinned tool versions to match CI.</p> <p>!!! note 'Getting Started Overview'     This guide walks you through local preflight, Admin Console access, first plugin, and common developer checks. It's dyslexia-friendly with clear sections and visual cues.</p> <p>!!! warning 'Admin Console Mandate'     No CLI-only features: every capability must be available from the Admin Console.</p>"},{"location":"getting-started/#table-of-contents","title":"Table of contents","text":""},{"location":"getting-started/#local-ci-parity","title":"Local CI Parity","text":""},{"location":"getting-started/#admin-console-access","title":"Admin Console Access","text":""},{"location":"getting-started/#first-plugin-install-register","title":"First Plugin: Install &amp; Register","text":""},{"location":"getting-started/#quick-debugging-checklist","title":"Quick Debugging Checklist","text":""},{"location":"getting-started/#local-ci-parity_1","title":"Local CI Parity","text":"<p>!!! info 'Why this matters'     CI mirrors exact tool versions; mismatches lead to noisy CI failures. The preflight ensures parity.</p> <ul> <li> <p>:material-shield-check:{ .lg .middle } Reproducible Environment</p> <p>Python 3.11 virtualenv + pinned deps</p> </li> <li> <p>:material-check-circle:{ .lg .middle } Pre-commit Hooks</p> <p>pre-commit runs black, flake8, mypy, and pytest on push</p> </li> </ul>"},{"location":"getting-started/#run-the-preflight-local-ci-parity","title":"Run the preflight (local CI parity)","text":"PythonNode.jscurl <pre><code># (1)\n# Create and activate Python 3.11 venv, install exact deps\nimport subprocess\nsubprocess.run([\"python3.11\", \"-m\", \"venv\", \".venv\"])\n# (2)\n# Activate and install pinned packages\n# This is illustrative; use the bash variant below for exact commands\n</code></pre> <pre><code>// (1)\n// This is a placeholder: UI build uses npm ci &amp;&amp; npm run build in UI folders\n// (2) Use make ui-ci-local to run optional UI parity\nconsole.log('Run UI build in core/ui and core/admin_ui when node is present');\n</code></pre> <pre><code># (1) Exact preflight commands (run from repo root)\npython3.11 -m venv .venv &amp;&amp; . .venv/bin/activate\npip install -r core/requirements.txt \\\n  black==25.9.0 flake8==7.3.0 mypy==1.18.2 sqlalchemy==2.0.23 \\\n  pytest pytest-cov pytest-asyncio\n\n# (2) Lint/type/test\nblack --check core/ || (echo 'Run: black core/' &amp;&amp; exit 1)\nflake8 core/\nmypy --config-file mypy.ini core/\nPYTHONPATH=$PWD pytest -q\n</code></pre> <ol> <li>Create an environment exactly like CI</li> <li>Install pinned tools and run checks locally</li> </ol> <p>??? note 'Pre-commit setup'     To install recommended pre-commit hooks, run the block below in your repo root. This ensures consistent linting and testing on push.</p> PythonNode.jscurl <pre><code># (1)\n# Use pip to install pre-commit and write the YAML as shown\n</code></pre> <pre><code>// (1)\n// Node-based UI parity is optional but recommended. Add 'ui-ci-local' to Makefile.\n</code></pre> <pre><code>pip install pre-commit\ncat &gt; .pre-commit-config.yaml &lt;&lt;'YAML'\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 25.9.0\n    hooks: [{ id: black }]\n  - repo: https://github.com/PyCQA/flake8\n    rev: 7.3.0\n    hooks: [{ id: flake8 }]\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.18.2\n    hooks:\n      - id: mypy\n        additional_dependencies: [\"sqlalchemy==2.0.23\"]\n  - repo: local\n    hooks:\n      - id: pytest\n        name: pytest (pre-push)\n        entry: bash -c 'PYTHONPATH=$PWD pytest -q'\n        language: system\n        pass_filenames: false\n        stages: [push]\nYAML\npre-commit install -t pre-commit -t pre-push\n</code></pre>"},{"location":"getting-started/#admin-console-access_1","title":"Admin Console Access","text":"<p>!!! tip 'Primary Interface'     The Admin Console is the primary UI for managing the platform. All features are accessible through the web interface.</p> Area Description Access Dashboard System health, metrics, quick actions Admin role Plugins Marketplace, register/unregister plugins Admin role Settings Global config &amp; environment variables Admin role"},{"location":"getting-started/#keyboard-shortcuts-examples","title":"Keyboard shortcuts (examples)","text":"<ul> <li>Ctrl+K to open command palette</li> <li>Ctrl+S to save changes in forms</li> </ul> <p>??? note 'UI Build'     If your push includes UI code, the CI will run a separate Docker UI build job. Ensure local builds pass with ++make ui-ci-local++ when possible.</p>"},{"location":"getting-started/#first-plugin-install-register_1","title":"First Plugin: Install &amp; Register","text":"<p>!!! info 'Plugin model'     Plugins are first-class: they expose roles, Admin UI components, and configuration. Use the Plugin Marketplace in the Admin Console to register a new plugin.</p> <ul> <li> <p>:material-puzzle:{ .lg .middle } Plugin Extensibility</p> <p>Plugins can provide canonical adapters, event handlers, and UI widgets</p> </li> <li> <p>:material-widgets:{ .lg .middle } Marketplace</p> <p>Install or register plugins via the Admin Console or API</p> </li> </ul>"},{"location":"getting-started/#quick-register-via-admin-api","title":"Quick register via Admin API","text":"PythonNode.jscurl <pre><code># (1)\nimport requests\nresp = requests.post('https://admin.example/api/plugins', json={'name': 'my-plugin'})\n# (2)\nprint(resp.status_code)\n</code></pre> <pre><code>// (1)\nconst fetch = require('node-fetch')\n// (2)\nfetch('https://admin.example/api/plugins', { method: 'POST', body: JSON.stringify({ name: 'my-plugin' }) })\n</code></pre> <pre><code># (1)\ncurl -X POST https://admin.example/api/plugins -H 'Content-Type: application/json' -d '{\"name\":\"my-plugin\"}'\n</code></pre> <ol> <li>Use the Admin API to register plugins programmatically</li> <li>Prefer the Admin Console for guided workflows and verification</li> </ol>"},{"location":"getting-started/#quick-debugging-checklist_1","title":"Quick Debugging Checklist","text":"<ul> <li> Run ++make ci-local++ or preflight commands</li> <li> Build Admin UI locally (++make ui-ci-local++) when changing UI</li> <li> Ensure branch protection checks are green before merge</li> </ul> <p><code>mermaid graph LR   Dev[Developer] --&gt;|run preflight| LocalCI[Local CI Parity]   LocalCI --&gt;|passes| GitHub[Push to repo]   GitHub --&gt; CI[CI Pipeline]   CI --&gt;|green| Merge[Merge to integration]</code></p> <p>!!! danger 'Merge protection'     Do not merge if local parity fails. Agents and automation rely on green main/integration branches.</p> <p>??? note 'Advanced'     For agent gating and advanced automation (poll PR merge or wait-merge), see the Admin API and tools/scripts in the repo.</p> <ol> <li> <p>Local CI parity is required to prevent CI-only failures.\u00a0\u21a9</p> </li> </ol>"},{"location":"installation/","title":"Installation","text":"<p>This page will cover installation methods for Vivified (Docker Compose, Kubernetes manifests, and bare\u2011metal dev). For now, see Getting Started for local dev.</p>"},{"location":"monitoring/","title":"Monitoring","text":"<p>Metrics and health endpoints. Prometheus metrics at <code>/metrics</code>; Gateway and Messaging stats under Admin API.</p>"},{"location":"security/","title":"Overview","text":"<ul> <li> <p>:material-security:{ .lg .middle } Security &amp; Compliance</p> <p>HIPAA-aligned controls: encryption, audit, RBAC, retention</p> </li> <li> <p>:material-shield-check:{ .lg .middle } Zero Trust</p> <p>Per-service auth, token scopes, and mTLS options</p> </li> <li> <p>:material-history:{ .lg .middle } Audit &amp; Evidence</p> <p>Logs and retention policies for compliance evidence</p> </li> </ul> <p>!!! tip 'Least privilege'     Grant minimal roles to service accounts and human users. Prefer short-lived tokens and role-scoped credentials.</p> <p>!!! note 'Encryption standards'     - At rest: AES-256 (envelope encryption)     - In transit: TLS 1.2+ with strong ciphers</p> <p>!!! danger 'PHI exposure'     Never write PHI to public or debug logs. Use structured logging with explicit masked fields.</p>"},{"location":"security/#security-controls","title":"Security controls","text":"Control Description Status HIPAA Encryption (rest) AES-256 envelope \u2705 Compliant Encryption (transit) TLS 1.2+ \u2705 Compliant RBAC Role-based access control \u2705 Compliant Audit logs 7-year retention \u2705 Compliant <p><code>mermaid graph LR   User --&gt; Auth[Auth Service]   Auth --&gt;|issue token| API   API --&gt; PolicyEngine   PolicyEngine --&gt; Storage   Storage --&gt; KMS   KMS --&gt;|wrap| Keys</code></p>"},{"location":"security/#key-practices","title":"Key practices","text":"<ul> <li>Rotate KMS keys regularly</li> <li>Use centralized secrets management for service tokens</li> <li>Encrypt backups and restrict access</li> </ul>"},{"location":"security/#incident-response-checklist","title":"Incident response checklist","text":"<ul> <li> Revoke compromised tokens</li> <li> Rotate keys where feasible</li> <li> Preserve and secure audit logs</li> <li> Notify compliance officer if PHI implicated</li> </ul>"},{"location":"security/#policy-configuration-table","title":"Policy &amp; configuration table","text":"Policy Purpose Required Notes DATA_RETENTION_YEARS How long PHI is stored 7 Regulatory baseline AUDIT_RETENTION_YEARS How long audit logs are kept 7 Evidence for compliance ACCESS_APPROVAL Manual approval for plugin PHI access yes For production <p>!!! warning 'Audit integrity'     Ensure timestamps and actor identity cannot be tampered with. Use signed audit entries and append-only stores.</p> <p>??? note 'Third-party integrations'     Vet third-party services for HIPAA Business Associate Agreement (BAA) before sending PHI.</p> <ol> <li> <p>Security policies are enforced across gateway, API, storage, and messaging layers.\u00a0\u21a9</p> </li> </ol>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<ul> <li> <p>:material-alert-circle:{ .lg .middle } Troubleshooting</p> <p>Quick resolutions for common developer and operator issues</p> </li> <li> <p>:material-bug-report:{ .lg .middle } Common Pitfalls</p> <p>Mypy, flake8, black, and SQLAlchemy typer pitfalls</p> </li> <li> <p>:material-help:{ .lg .middle } Debugging Playbook</p> <p>Step-by-step checks for CI parity and UI issues</p> </li> </ul> <p>!!! tip 'Start local parity'     When CI fails, always run the Local CI Parity preflight from getting-started before filing issues.</p> <p>!!! note 'Common errors'     The most frequent root causes are typing mistakes, mutable defaults, and import-time side effects.</p> <p>!!! warning 'UI missing files'     If the Admin UI references components not committed, tsc --noEmit will typically catch missing imports; add UI coverage to pre-push hooks.</p>"},{"location":"troubleshooting/#quick-fixes-table","title":"Quick fixes table","text":"Symptom Likely cause Quick fix mypy errors about Optional Missing explicit Optional[T] Use T Tests failing intermittently Async session misuse Use async_sessionmaker and async with Black/flake8 failures Formatting/lint issues Run black core/ and flake8 core/"},{"location":"troubleshooting/#debugging-workflow","title":"Debugging workflow","text":"<p><code>mermaid graph TD   Developer --&gt; LocalPreflight   LocalPreflight --&gt;|passes| Push   Push --&gt;|CI fails| CILogs   CILogs --&gt; Developer   Developer --&gt; Fix   Fix --&gt; LocalPreflight</code></p>"},{"location":"troubleshooting/#example-run-the-full-local-parity","title":"Example: run the full local parity","text":"PythonNode.jscurl <pre><code># (1)\n# Run all checks programmatically (simple wrapper)\nimport subprocess\nsubprocess.run(['bash', '-c', 'python3.11 -m venv .venv &amp;&amp; . .venv/bin/activate &amp;&amp; pip install -r core/requirements.txt'])\n</code></pre> <pre><code>// (1)\n// Trigger UI build for local parity\n// (cd core/admin_ui &amp;&amp; npm ci &amp;&amp; npm run build)\n</code></pre> <pre><code># (1)\npython3.11 -m venv .venv &amp;&amp; . .venv/bin/activate\npip install -r core/requirements.txt \\\n  black==25.9.0 flake8==7.3.0 mypy==1.18.2 sqlalchemy==2.0.23 \\\n  pytest pytest-cov pytest-asyncio\nblack --check core/ || (echo 'Run: black core/' &amp;&amp; exit 1)\nflake8 core/\nmypy --config-file mypy.ini core/\nPYTHONPATH=$PWD pytest -q\n</code></pre> <ol> <li>Run exact tool versions locally</li> </ol>"},{"location":"troubleshooting/#error-catalogue-and-remedies","title":"Error catalogue and remedies","text":"Error Explanation Remedy Type error implicit Optional Parameter default None not annotated Annotate as T Mutable default list Using = [] in dataclass Use field(default_factory=list) Import side effects DB/network calls at import Lazy-init or fixtures in tests <p>!!! note 'Async tests'     Remember to install pytest-asyncio and mark async tests with ++@pytest.mark.asyncio++.</p> <p>??? note 'When to escalate'     If you see infrastructure-level failures (KMS, DB), collect logs, audit entries, and environment details before contacting platform SRE.</p> <ol> <li> <p>Keeping local parity in sync with CI prevents the majority of failed pushes.\u00a0\u21a9</p> </li> </ol>"},{"location":"_autopilot/plan/","title":"Docs Autopilot Plan","text":"<p>Generated: 2025-09-28T20:42:53.683590</p>"},{"location":"_autopilot/plan/#changes-detected","title":"Changes detected","text":"<ul> <li>core: 2 file(s)</li> <li>other: 2 file(s)</li> </ul>"},{"location":"_autopilot/plan/#suggested-documentation-updates","title":"Suggested documentation updates","text":"<ul> <li>Update Core overview and API references if endpoints or models changed.</li> <li>Consider adding release notes or changelog entries.</li> </ul>"},{"location":"admin-console/configuration/","title":"Admin Console: Configuration","text":"<p>Edit global and plugin configuration. Secrets are stored in ConfigService (encrypted in production). Changes are audited.</p>"},{"location":"admin-console/dashboard/","title":"Admin Console: Dashboard","text":"<p>The dashboard surfaces health and jump links to Diagnostics, Jobs, Inbox, and Settings. Each card links to its detailed counterpart.</p>"},{"location":"admin-console/monitoring/","title":"Admin Console: Monitoring","text":"<p>View service and plugin health, gateway stats, and key metrics. Includes links to Prometheus endpoints and logs.</p>"},{"location":"admin-console/users/","title":"Admin Console: Users","text":"<p>Manage users, roles, and traits. Trait-aware rendering ensures least-privilege experiences across the UI.</p>"},{"location":"ai/overview/","title":"AI &amp; Agents (RAG + LLM)","text":"<p>This page documents Vivified\u2019s internal AI features: repository\u2011wide RAG (indexing your code and docs), a trait\u2011aware query path, semantic retrieval with embeddings, and an agent that can call an LLM through the Core gateway with strict allowlists. RAG prefers Redis as the default backend when available, with graceful fallback to in\u2011memory storage.</p> <p>Important: This is an internal/developer feature set. Customer\u2011facing docs will be derived from this page later.</p>"},{"location":"ai/overview/#features","title":"Features","text":"<ul> <li>Repository\u2011wide RAG (Redis\u2011backed by default) with embeddings</li> <li>Indexes the entire repo (<code>.</code>) by default and respects <code>.ragignore</code> first, then <code>.gitignore</code>.</li> <li>Ignore patterns support anchored paths (<code>/path</code>), directory suffix (<code>dir/</code>), and globbing (<code>*.log</code>).</li> <li>Reads any text\u2011decodable file up to <code>RAG_MAX_BYTES</code> (default 2\u202fMB); binary blobs are skipped.</li> <li>Backend selection: if <code>REDIS_URL</code> is set or Redis is reachable at <code>redis://localhost:6379/0</code>, Redis is used; otherwise falls back to memory.</li> <li>Vector search: chunks are embedded via OpenAI embeddings (default <code>text-embedding-3-small</code>) and ranked by cosine similarity; falls back to sparse token overlap if embeddings are unavailable.</li> <li>Chunking</li> <li><code>RAG_CHUNK_CHARS</code> default 4000; <code>RAG_OVERLAP_CHARS</code> default 400.</li> <li>Each chunk carries <code>required_traits</code> and <code>classification</code> metadata used at query time (TBAC).</li> <li>UI controls: Admin \u2192 Tools \u2192 AI Studio \u2192 Ingestion Rules \u2192 RAG Settings lets you set Chunk Size and Overlap without env changes.</li> <li>Trait\u2011aware querying (TBAC)</li> <li>Only returns documents where <code>required_traits \u2286 user.traits</code>.</li> <li>Defaults to <code>required_traits=[]</code> for code/docs; add traits to sensitive datasets to gate access.</li> <li>LLM agent through Core gateway (egress allowlist)</li> <li>Proxies to OpenAI via <code>/gateway/proxy</code> with plugin_id <code>ai-core</code> (allowlist seeded for chat completions).</li> <li>Falls back to a direct call if proxy is unavailable.</li> <li>Default model: <code>gpt-5-mini</code> (override with <code>AI_LLM_MODEL</code> or <code>OPENAI_DEFAULT_MODEL</code>).</li> <li>Auto\u2011training on startup (optional) and periodic updates</li> <li><code>AI_AUTO_TRAIN=true</code> indexes <code>.</code> on startup.</li> <li><code>RAG_UPDATE_INTERVAL_MINUTES</code> controls retraining cadence (default 20 minutes).</li> </ul>"},{"location":"ai/overview/#quick-start","title":"Quick Start","text":"<p>1) Start Core with <code>.env</code> (OpenAI key optional):</p> <pre><code>uvicorn core.main:app --reload\n</code></pre> <p>2) (Optional) Auto\u2011train on startup and enable 20\u2011minute updates:</p> <pre><code>export AI_AUTO_TRAIN=true\nexport RAG_UPDATE_INTERVAL_MINUTES=20\nuvicorn core.main:app --reload\n</code></pre> <p>3) Open Admin Console \u2192 Tools \u2192 \u201cAI Studio\u201d    - Click \u201cTrain from Docs\u201d to index the repo now (respects ignore files).    - Pick Provider from the dropdown (OpenAI, Claude, or Local). When a provider is selected, the Model dropdown auto\u2011loads available models from the provider (<code>/admin/ai/models</code>) with your configured key and base URL. For Local (e.g., Ollama), popular tags are shown when reachable; otherwise, type your model.    - Search the index and run Agent to get a human\u2011readable answer with code/docs context.</p>"},{"location":"ai/overview/#admin-api","title":"Admin API","text":"<ul> <li><code>GET /admin/ai/status</code> \u2192 <code>{ docs_indexed, last_trained_ts, backend }</code> (admin)</li> <li><code>POST /admin/ai/train</code> \u2192 <code>{ ok, indexed, total }</code> (admin)</li> <li>Body: <code>{ sources?: string[] }</code> (defaults to <code>\".\"</code>)</li> <li><code>POST /admin/ai/query</code> \u2192 <code>{ items }</code> (viewer/admin)</li> <li>Body: <code>{ q: string }</code> (filters by user traits)</li> <li><code>POST /admin/ai/agent/run</code> \u2192 <code>{ result }</code> (admin)</li> <li>Body: <code>{ prompt: string }</code></li> <li><code>GET /admin/ai/models?provider=openai&amp;typ=chat|embeddings</code> \u2192 <code>{ provider, type, models }</code> (viewer/admin)</li> <li>Lists model IDs using provider APIs via the Core gateway; includes sensible fallbacks when APIs are unavailable.</li> </ul> <p>Notes: - The server reads <code>.env</code> at startup; set <code>OPENAI_API_KEY</code> to use live LLM and embeddings. - Default chat model is <code>gpt-5-mini</code>; override via <code>AI_LLM_MODEL</code>. - Default embeddings model is <code>text-embedding-3-small</code>; override via Admin \u2192 AI Studio or <code>EMBEDDING_MODEL</code>/<code>OPENAI_EMBEDDING_MODEL</code>. - RAG defaults: <code>REDIS_URL=redis://localhost:6379/0</code> (if reachable); otherwise memory.  - Optional RAG backend: set Backend=Plugin and choose your plugin id to delegate indexing/search over the operator lane. Your plugin implements <code>rag_index</code> and <code>rag_query</code> (see Plugins \u2192 RAG DB Plugin).  - Optional: Use Redis Stack for native vector indices; run <code>redis-stack</code> service from docker-compose and set <code>REDIS_URL=redis://localhost:6380/0</code>.</p>"},{"location":"ai/overview/#ignore-model","title":"Ignore Model","text":"<ul> <li><code>.ragignore</code> (optional) has priority over <code>.gitignore</code>.</li> <li>Patterns:</li> <li>Anchored path: <code>/build/</code> matches from repo root.</li> <li>Directory: <code>cache/</code> prunes entire subtree.</li> <li>Glob: <code>*.log</code>, <code>*.tmp</code>, <code>node_modules/</code>, etc.</li> </ul> <p>Example <code>.ragignore</code>:</p> <pre><code>/site/\n/node_modules/\n*.png\n*.jpg\n*.pdf\n</code></pre>"},{"location":"ai/overview/#ingestion-rules-required_traitsclassification","title":"Ingestion Rules (required_traits/classification)","text":"<p>You can attach trait requirements and classification labels to files based on path globs. The indexer will read two optional ConfigService keys:</p> <pre><code>ai.rag.required_traits = {\n  \"internal-plans/**\": [\"internal_docs\"],\n  \"data/analytics/**\": [\"analytics_viewer\"],\n  \"**/*.sql\": [\"dba_viewer\"]\n}\n\nai.rag.classification = {\n  \"data/analytics/**\": [\"sensitive\"],\n  \"docs/**\": [\"internal\"]\n}\n</code></pre> <p>Only documents whose <code>required_traits</code> are a subset of the current user's traits are considered at query time. Use this to keep PII-gated datasets out of the assistant\u2019s view while permitting HIPAA\u2011safe analytics.</p>"},{"location":"ai/overview/#tbac-hipaasafe","title":"TBAC (HIPAA\u2011safe)","text":"<ul> <li>Each document has <code>required_traits</code> (default <code>[]</code>) and <code>classification</code> (default <code>internal</code>).</li> <li>Query filters results to those with <code>required_traits \u2286 user.traits</code>.</li> <li>Pattern: Place analytics\u2011safe data behind a trait such as <code>analytics_viewer</code> and exclude PII traits entirely. The agent can answer aggregate questions without ever seeing names/addresses.</li> </ul>"},{"location":"ai/overview/#llm-via-gateway","title":"LLM via Gateway","text":"<ul> <li>The agent calls OpenAI via Core\u2019s <code>/gateway/proxy</code> using plugin_id <code>ai-core</code>. Fallback is direct.</li> <li>On startup we seed an allowlist for <code>api.openai.com</code> POST <code>/v1/chat/completions</code>.</li> <li>Configure (prefer ConfigService over env):</li> <li>Admin \u2192 Tools \u2192 AI Studio \u2192 LLM Configuration to set provider (<code>openai</code>, <code>claude</code>, or <code>local</code>), model, base URL, embeddings model, and API key securely.</li> <li>Or via API: <code>GET/PUT /admin/ai/config</code>.</li> <li>Legacy endpoints: <code>GET/PUT /admin/ai/connectors</code>.</li> </ul>"},{"location":"ai/overview/#mcp-preview","title":"MCP (Preview)","text":"<ul> <li>Health: <code>GET /mcp/sse/health</code>, <code>GET /mcp/http/health</code>.</li> <li>Tool: <code>POST /mcp/http/tools/rag/query</code> \u2192 <code>{ items }</code> (viewer/admin), body <code>{ q: string }</code>.</li> <li>Settings (Admin \u2192 Settings \u2192 MCP) toggle SSE/HTTP and optional OAuth.</li> </ul>"},{"location":"ai/overview/#cli-helper","title":"CLI Helper","text":"<pre><code>AI_API_URL=http://localhost:8000 API_KEY=bootstrap_admin_only \\\n  python tools/scripts/rag_train.py --sources .\n</code></pre>"},{"location":"ai/overview/#smoke-test","title":"Smoke Test","text":"<p>To verify RAG + embeddings end\u2011to\u2011end locally:</p> <pre><code>API_KEY=bootstrap_admin_only AI_API_URL=http://localhost:8000 \\\n  OPENAI_API_KEY=sk-... \\\n  python tools/scripts/rag_smoke.py --train --query \"Vivified core platform\"\n</code></pre> <p>The script checks status, trains (if requested), performs a query, and reports the backend (redis/memory) and number of results.</p>"},{"location":"ai/overview/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\u201cDocs haven\u2019t updated\u201d</li> <li>The site publishes from <code>gh-pages</code> via mike. Re\u2011deploy: <code>mike deploy latest -u -p &amp;&amp; mike set-default latest -p</code>.</li> <li>Hard refresh the browser to bypass CDN caching.</li> <li>\u201cLLM calls failing\u201d</li> <li>Confirm <code>OPENAI_API_KEY</code> is present and not expired.</li> <li>Check <code>/gateway/allowlist/effective?plugin_id=ai-core</code> shows OpenAI allowlist.</li> <li>Review <code>/gateway/stats</code> and audit logs.</li> <li>\u201cIndex skipped files unexpectedly\u201d</li> <li>Inspect <code>.ragignore</code> and <code>.gitignore</code> matches (anchored vs glob). Remove overly broad patterns.</li> </ul>"},{"location":"ai/overview/#roadmap","title":"Roadmap","text":"<ul> <li>Config v4 secrets for provider keys + traited ingestion rules per path.</li> <li>LangGraph agent pipeline with RAG retriever + HTTP/Storage tools.</li> <li>Expose RAG query as a full MCP tool bundle (SSE/HTTP) with schemas.</li> </ul>"},{"location":"api/graphql/","title":"GraphQL API","text":"<p>GraphQL support is planned. Current interfaces are REST and SSE; rich plugin contracts are exposed via Admin API.</p>"},{"location":"api/websocket/","title":"WebSocket API","text":"<p>WebSocket endpoints and event streaming (planned). For now, use SSE endpoints under <code>/mcp/sse</code> and standard REST APIs.</p>"},{"location":"architecture/diagrams/","title":"Architecture Diagrams","text":"<p>System architecture diagrams and flow charts. See also: Three-Lane Model.</p>"},{"location":"architecture/diagrams/#three-lane-overview","title":"Three-Lane Overview","text":"<p>```mermaid flowchart TB   %% Three-Lane overview with wrapped labels   classDef box fill:#eef5ff,stroke:#4c6ef5,color:#222,stroke-width:1px</p> <p>subgraph Plugin[Plugin Container\\n(no outbound network)]     P1[\"LLM Plugin\\nclassify=PHI\\ntrace_id=...\\nrefs not raw PHI\"]:::box   end</p> <p>CoreGW[\"Core Gateway\\n(Operator RPC)\"]:::box   Canonical[\"Canonical Engine\\n(schema + policy + audit)\"]:::box   Proxy[\"Core Proxy\\n(allowlist + TLS + secrets)\"]:::box   Vectorizer[\"Vectorizer Plugin\\n(Embed op)\"]:::box</p> <p>P1 -- \"Operator: Embed\" \u2192 CoreGW   CoreGW -- \"dispatch\" \u2192 Vectorizer   P1 -- \"Canonical: DocumentSummarized\" \u2192 Canonical   P1 -- \"Proxy: chat completions\" \u2192 Proxy</p> <p>class P1,CoreGW,Canonical,Proxy,Vectorizer box ```</p>"},{"location":"architecture/diagrams/#defaults-and-fallbacks","title":"Defaults and Fallbacks","text":"<p>```mermaid flowchart TB   %% Default backends and fail-safe fallbacks   classDef box fill:#f4fff4,stroke:#2e7d32,color:#222,stroke-width:1px   classDef warn fill:#fff8e1,stroke:#f9a825,color:#222,stroke-width:1px</p> <p>subgraph Core[Core Services]     DB[(Postgres\\npostgresql+asyncpg)]:::box     RAG[(Redis\\nredis://localhost:6379/0)]:::box   end</p> <p>subgraph Fallbacks[Graceful Fallbacks]     MemDB[(SQLite in-tests\\nTEST_DB_URL or in-memory)]:::warn     MemRAG[(In-memory RAG\\nif Redis unreachable)]:::warn   end</p> <p>Core \u2192 Fallbacks   DB -. tests only .-&gt; MemDB   RAG -. on failure .-&gt; MemRAG ```</p>"},{"location":"core/","title":"Index","text":"<ul> <li> <p>:material-shield-check:{ .lg .middle } Core Services</p> <p>Canonical, Storage, Messaging, API, Gateway \u2014 secure, modular services</p> </li> <li> <p>:material-format-list-bulleted:{ .lg .middle } Service Catalog</p> <p>Service contract and integrations for plugins and Admin API</p> </li> <li> <p>:material-security:{ .lg .middle } Compliance Built-in</p> <p>Encryption, audit logs, retention policies aligned to HIPAA</p> </li> </ul> <p>!!! tip 'Readability'     Each core service is documented separately (canonical, storage, messaging, gateway). Use this index as the quick map.</p> <p>!!! note 'User-facing focus'     The docs below describe how to operate, configure, and integrate with core services \u2014 not internal roadmap.</p> <p>!!! warning 'Audit trails'     All PHI/PII-affecting operations are audit-logged. Ensure your integration preserves audit context.</p>"},{"location":"core/#core-services-overview","title":"Core Services Overview","text":"Service Primary Function Status HIPAA canonical Data normalization &amp; transformation \u2705 Active Compliant storage Encrypted PHI/PII storage \u2705 Active Compliant messaging Event bus &amp; inter-plugin comms \u2705 Active Compliant api Admin API (role-based) \u2705 Active Compliant gateway External proxy &amp; validation \u2705 Active Compliant"},{"location":"core/#architecture","title":"Architecture","text":"<p><code>mermaid graph LR   User[Admin UI / Client] --&gt;|HTTPS| Gateway   Gateway --&gt; API[Admin API]   API --&gt; Canonical   API --&gt; Storage   API --&gt; Messaging   Messaging --&gt;|events| Plugins   Storage --&gt;|encrypted| Database[(Encrypted DB)]</code></p> <p>??? note 'Service contracts'     Each core service exposes stable REST/gRPC or async interfaces documented in the service subpages.</p>"},{"location":"core/#links","title":"Links","text":"<ul> <li>core/canonical.md \u2014 Canonical data models and normalization</li> <li>core/storage.md \u2014 Encrypted storage and retention</li> <li>core/messaging.md \u2014 Event bus and message flows</li> <li>core/gateway.md \u2014 External API gateway and filtering</li> </ul> <ol> <li> <p>Core services are the user-facing integration points for plugins and admin operations.\u00a0\u21a9</p> </li> </ol>"},{"location":"core/admin_ui/","title":"Admin UI","text":"<pre><code>{\n  \"overview\": \"# Admin UI Service Documentation\\n\\n## Overview\\n\\nThe **admin_ui** service is a critical component of the Vivified platform, designed to provide a secure and user-friendly administrative interface for managing enterprise data and configurations. As a HIPAA-compliant service, it ensures the protection and confidentiality of health information.\\n\\n!!! note\\n    This service is part of the Vivified platform's suite of HIPAA-compliant enterprise solutions, ensuring that all data handling meets stringent regulatory standards.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[User] --&gt;|Access| B[admin_ui Service];\\n    B --&gt;|Retrieve| C[Data Layer];\\n    B --&gt;|Send| D[Audit Logs];\\n    C --&gt;|Process| E[HIPAA-Compliant Storage];\\n```\\n\\n## Key Features\\n- Secure admin interface for managing platform settings.\\n- Audit logging for all administrative actions.\\n- Integration with the Vivified data layer to ensure data integrity and compliance.\\n\\n## Security Considerations\\n\\n!!! warning\\n    Ensure all users accessing the admin_ui service have appropriate permissions and undergo regular security training to maintain compliance.\\n\\n- **Access Control**: Implement role-based access control (RBAC) to restrict access.\\n- **Encryption**: All data in transit and at rest is encrypted using industry-standard protocols.\\n- **Audit Logging**: Every action within the admin_ui is logged for audit purposes, with logs stored securely.\\n\",\n  \"api\": \"# Admin UI API Reference\\n\\nThe admin_ui service provides a RESTful API for programmatic access to its features.\\n\\n## Authentication\\nAll API endpoints require an API key and OAuth2 token for access.\\n\\n## Endpoints\\n\\n### GET /api/admin/settings\\nRetrieve current platform settings.\\n\\n```json\\n{\\n  \\\"endpoint\\\": \\\"/api/admin/settings\\\",\\n  \\\"method\\\": \\\"GET\\\",\\n  \\\"description\\\": \\\"Retrieve current platform settings.\\\"\\n}\\n```\\n\\n### POST /api/admin/settings\\nUpdate platform settings.\\n\\n```json\\n{\\n  \\\"endpoint\\\": \\\"/api/admin/settings\\\",\\n  \\\"method\\\": \\\"POST\\\",\\n  \\\"description\\\": \\\"Update platform settings.\\\"\\n}\\n```\\n\\n!!! tip\\n    Use the POST method with caution, ensuring that all changes are compliant with organizational policies.\\n\",\n  \"config\": \"# Configuration Guide\\n\\n## Configuration Options\\n\\nThe admin_ui service can be configured using the following options:\\n\\n| Option        | Type    | Default | Description                                      |\\n|---------------|---------|---------|--------------------------------------------------|\\n| `port`        | Integer | 8080    | The port on which the service listens.           |\\n| `log_level`   | String  | info    | The level of logging detail (info, debug, warn). |\\n| `data_source` | String  |         | Connection string for the data source.           |\\n\\n### Example Configuration\\n\\n```yaml\\nport: 8080\\nlog_level: info\\ndata_source: \\\"postgres://user:password@localhost:5432/admin_db\\\"\\n```\\n\",\n  \"examples\": \"# Usage Examples\\n\\n## Accessing the Admin UI\\n\\n=== \\\"Python\\\"\\n    ```python\\n    import requests\\n\\n    url = \\\"https://vivified-platform.com/api/admin/settings\\\"\\n    headers = {\\n        \\\"Authorization\\\": \\\"Bearer YOUR_ACCESS_TOKEN\\\",\\n        \\\"Content-Type\\\": \\\"application/json\\\"\\n    }\\n    \\n    response = requests.get(url, headers=headers)\\n    print(response.json())\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X GET \\\"https://vivified-platform.com/api/admin/settings\\\" \\\\\\n    -H \\\"Authorization: Bearer YOUR_ACCESS_TOKEN\\\" \\\\\\n    -H \\\"Content-Type: application/json\\\"\\n    ```\\n\\n## Updating Settings\\n\\n=== \\\"Python\\\"\\n    ```python\\n    import requests\\n    import json\\n\\n    url = \\\"https://vivified-platform.com/api/admin/settings\\\"\\n    headers = {\\n        \\\"Authorization\\\": \\\"Bearer YOUR_ACCESS_TOKEN\\\",\\n        \\\"Content-Type\\\": \\\"application/json\\\"\\n    }\\n    \\n    data = json.dumps({\\\"setting_key\\\": \\\"new_value\\\"})\\n    response = requests.post(url, headers=headers, data=data)\\n    print(response.status_code)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X POST \\\"https://vivified-platform.com/api/admin/settings\\\" \\\\\\n    -H \\\"Authorization: Bearer YOUR_ACCESS_TOKEN\\\" \\\\\\n    -H \\\"Content-Type: application/json\\\" \\\\\\n    -d '{\\\"setting_key\\\": \\\"new_value\\\"}'\\n    ```\\n\\n## Troubleshooting\\n\\n!!! note\\n    Always ensure your API key and access tokens are valid.\\n\\n- **403 Forbidden**: Check if your API key has the necessary permissions.\\n- **500 Internal Server Error**: Verify that the service is running and accessible.\\n- **400 Bad Request**: Ensure JSON payloads are correctly formatted and contain all required fields.\\n\"\n}\n</code></pre>"},{"location":"core/api/","title":"API","text":"<pre><code>{\n  \"overview\": \"# Vivified Platform API Service Documentation\\n\\nThe **Vivified API Service** is a crucial component of the Vivified platform, designed to handle authentication, user management, configuration settings, and notifications. As a HIPAA-compliant service, it ensures the protection of sensitive health information through robust security measures.\\n\\n## Architecture Overview\\n\\nThe service is built using FastAPI, supporting asynchronous operations and providing a high-performance environment for handling RESTful API requests.\\n\\n```mermaid\\ngraph TD;\\n    A[Client] --&gt;|HTTP Request| B[API Gateway];\\n    B --&gt; C[Auth Module];\\n    B --&gt; D[Admin Module];\\n    B --&gt; E[Notifications Module];\\n    C --&gt; F[Identity Service];\\n    D --&gt; G[Database];\\n    E --&gt; H[Notifications Service];\\n```\\n\\n!!! note\\n    The API service is part of a larger microservices architecture, with each service component interacting via well-defined interfaces.\\n\\n\",\n  \"api\": \"# API Reference\\n\\n## Authentication\\n\\n### Login\\n\\n- **Endpoint:** `/auth/login`\\n- **Method:** POST\\n\\n#### Request\\n\\n```python\\nclass LoginRequest(BaseModel):\\n    username: str\\n    password: str\\n```\\n\\n=== \\\"Python\\\"\\n```python\\nimport requests\\n\\nurl = \\\"http://example.com/auth/login\\\"\\npayload = {\\n    \\\"username\\\": \\\"your_username\\\",\\n    \\\"password\\\": \\\"your_password\\\"\\n}\\nresponse = requests.post(url, json=payload)\\nprint(response.json())\\n```\\n\\n=== \\\"curl\\\"\\n```\\ncurl -X POST \\\"http://example.com/auth/login\\\" \\\\\\n-H \\\"Content-Type: application/json\\\" \\\\\\n-d '{\\\"username\\\": \\\"your_username\\\", \\\"password\\\": \\\"your_password\\\"}'\\n```\\n\\n#### Response\\n- **Success:** Returns authentication token and user details.\\n- **Failure:** HTTP 401 with \\\"Invalid credentials\\\".\\n\\n## User Management\\n\\n### Get Current User\\n\\n- **Endpoint:** `/auth/me`\\n- **Method:** GET\\n\\n#### Response\\nReturns user id and traits.\\n\\n=== \\\"Python\\\"\\n```python\\nimport requests\\n\\nurl = \\\"http://example.com/auth/me\\\"\\nheaders = {\\n    \\\"Authorization\\\": \\\"Bearer your_token\\\"\\n}\\nresponse = requests.get(url, headers=headers)\\nprint(response.json())\\n```\\n\\n=== \\\"curl\\\"\\n```\\ncurl -X GET \\\"http://example.com/auth/me\\\" \\\\\\n-H \\\"Authorization: Bearer your_token\\\"\\n```\\n\\n## Notifications\\n\\n### List Notifications\\n\\n- **Endpoint:** `/admin/notifications`\\n- **Method:** GET\\n\\n#### Response\\nReturns a list of notifications.\\n\\n=== \\\"Python\\\"\\n```python\\nimport requests\\n\\nurl = \\\"http://example.com/admin/notifications\\\"\\nheaders = {\\n    \\\"Authorization\\\": \\\"Bearer your_token\\\"\\n}\\nresponse = requests.get(url, headers=headers)\\nprint(response.json())\\n```\\n\\n=== \\\"curl\\\"\\n```\\ncurl -X GET \\\"http://example.com/admin/notifications\\\" \\\\\\n-H \\\"Authorization: Bearer your_token\\\"\\n```\\n\\n\",\n  \"config\": \"# Configuration Guide\\n\\nBelow is a table of key configuration options for the API service:\\n\\n| Option          | Description                                       | Default Value |\\n|-----------------|---------------------------------------------------|---------------|\\n| `key`           | Configuration key, max length of 255 characters   | None          |\\n| `value`         | Configuration value, can be any type              | None          |\\n| `is_sensitive`  | Boolean to mark if the value is sensitive         | False         |\\n| `reason`        | Optional reason for configuration change          | None          |\\n\\n!!! tip\\n    Sensitive configurations should be encrypted to adhere to HIPAA compliance standards.\\n\\n## Security Considerations\\n\\n- **Authentication:** Implement strong password policies and multi-factor authentication.\\n- **Data Encryption:** All sensitive data, including PHI, must be encrypted both at rest and in transit using AES-256.\\n- **Access Control:** Utilize role-based access control (RBAC) to restrict access to sensitive endpoints and data.\\n\\n\",\n  \"examples\": \"# Usage Examples\\n\\n## Python Example\\n\\n```python\\nimport requests\\n\\nlogin_url = \\\"http://example.com/auth/login\\\"\\nme_url = \\\"http://example.com/auth/me\\\"\\n\\n# Login and get token\\nlogin_payload = {\\n    \\\"username\\\": \\\"your_username\\\",\\n    \\\"password\\\": \\\"your_password\\\"\\n}\\nlogin_response = requests.post(login_url, json=login_payload)\\nlogin_data = login_response.json()\\n\\ntoken = login_data.get(\\\"token\\\")\\n\\n# Get current user information\\nheaders = {\\n    \\\"Authorization\\\": f\\\"Bearer {token}\\\"\\n}\\nme_response = requests.get(me_url, headers=headers)\\nprint(me_response.json())\\n```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n- **Issue:** HTTP 401 Unauthorized\\n  - **Solution:** Ensure that the username and password are correct and the account is active.\\n\\n- **Issue:** Notifications service unavailable\\n  - **Solution:** Verify that the Notifications Service is running and accessible. Check network configurations and service logs for errors.\\n\\n!!! warning\\n    Ensure all API requests utilize secure HTTPS connections to prevent data interception.\\n\\n\"\n}\n</code></pre>"},{"location":"core/architecture/","title":"Core Architecture","text":"<p>High-level overview of core services, three-lane communication (canonical, operator, proxy), TBAC, and plugin isolation. More details coming soon.</p>"},{"location":"core/audit/","title":"Audit","text":"<pre><code>{\n  \"overview\": \"# Audit Service Overview\\n\\nThe Audit Service in the Vivified platform ensures compliance with HIPAA regulations by providing structured logging utilities and auditing sensitive operations. This service is designed to log events with various levels of detail and supports future extensions to persist logs to an append-only store with specific retention policies.\\n\\n## Features\\n\\n- Structured logging for sensitive operations.\\n- Simple decorator for auditing actions.\\n- Support for various audit categories such as system, security, compliance, and user actions.\\n- Future support for append-only storage and data retention policies.\\n\\n!!! note \\\"HIPAA Compliance\\\"\\n    The audit service is designed to comply with HIPAA regulations, ensuring that all logged data is handled securely and with the necessary retention policies.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[Audit Event] --&gt; B{Audit Levels};\\n    B --&gt;|Minimal| C[Log to Console];\\n    B --&gt;|Standard| D[Log to File];\\n    B --&gt;|Detailed| E[Send to Central Logging Service];\\n    B --&gt;|Comprehensive| F[Persist to Audit Database];\\n```\\n\\n## Security Considerations\\n\\n!!! warning \\\"Security\\\"\\n    Ensure that all access to audit logs is restricted to authorized personnel only. Regular audits should be conducted to verify the integrity and security of the logged data.\",\n\n  \"api\": \"# API Reference\\n\\nThe Audit Service does not expose a direct API for external use. Instead, it is integrated into the platform to automatically handle logging as per the predefined categories and levels.\\n\\n### AuditCategory Enum\\n\\n```python\\nfrom enum import Enum\\n\\nclass AuditCategory(str, Enum):\\n    SYSTEM = \\\"system\\\"\\n    SECURITY = \\\"security\\\"\\n    COMPLIANCE = \\\"compliance\\\"\\n    USER_ACTION = \\\"user_action\\\"\\n```\\n\\n- **SYSTEM**: Logs related to system operations.\\n- **SECURITY**: Logs related to security events.\\n- **COMPLIANCE**: Logs ensuring compliance with legal requirements.\\n- **USER_ACTION**: Logs tracking user actions.\",\n\n  \"config\": \"# Configuration Guide\\n\\nThe audit service configuration is defined within the codebase and can be adjusted as per the operational requirements.\\n\\n## Configuration Options\\n\\n| Option          | Description                      | Default Value |\\n|-----------------|----------------------------------|---------------|\\n| `AuditLevel`    | Level of detail for audit logs   | `MINIMAL`     |\\n| `RetentionPolicy` | Retention policy for audit logs | `None`        |\\n\\nTo change the configuration, update the `AuditLevel` within the `service.py` file:\\n\\n```python\\nfrom .service import AuditLevel\\n\\ncurrent_audit_level = AuditLevel.STANDARD\\n```\\n\\n!!! tip \\\"Retention Policy\\\"\\n    Implement a retention policy in later phases to ensure compliance with HIPAA's data retention requirements.\",\n\n  \"examples\": \"# Usage Examples\\n\\nThe following examples demonstrate how to use the audit service in various scenarios.\\n\\n## Logging an Audit Event\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from .service import AuditEvent, AuditCategory\\n\\n    event = AuditEvent(\\n        event_type=\\\"access\\\",\\n        category=AuditCategory.SECURITY,\\n        action=\\\"login_attempt\\\",\\n        result=\\\"success\\\",\\n        description=\\\"User login successful\\\",\\n        user_id=\\\"user-123\\\"\\n    )\\n    logger.info(json.dumps(event.__dict__))\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X POST \\\\\\n        -H \\\"Content-Type: application/json\\\" \\\\\\n        -d '{\\n            \\\"event_type\\\": \\\"access\\\",\\n            \\\"category\\\": \\\"security\\\",\\n            \\\"action\\\": \\\"login_attempt\\\",\\n            \\\"result\\\": \\\"success\\\",\\n            \\\"description\\\": \\\"User login successful\\\",\\n            \\\"user_id\\\": \\\"user-123\\\"\\n        }' \\\\\\n        http://your-audit-service-endpoint/log\\n    ```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n- **Logs not being recorded**: Ensure the logger is correctly configured and the appropriate audit level is set.\\n- **Unauthorized access attempts**: Regularly review logs for any unauthorized access attempts, and ensure security protocols are enforced.\\n\\n!!! note \\\"Debug Mode\\\"\\n    Enable debug mode in the logging configuration to capture more detailed logs during troubleshooting.\"\n}\n</code></pre>"},{"location":"core/canonical/","title":"Canonical","text":"<pre><code>{\n  \"overview\": \"# Canonical Service Documentation\\n\\n## Introduction\\nThe **Canonical Service** is an integral component of the Vivified platform, designed to facilitate data normalization and ensure cross-plugin compatibility. This service is pivotal in maintaining consistent data formats across disparate systems, ensuring seamless integration and interoperability.\\n\\n!!! note\\n    The Canonical Service is HIPAA-compliant, ensuring that all data transformations adhere to stringent privacy and security standards.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[Data Input] --&gt; B[Canonical Service];\\n    B --&gt; C[Data Transformer];\\n    C --&gt; D[Canonical Models];\\n    C --&gt; E[Schema Registry];\\n    E --&gt; F[Schema Loader];\\n    D --&gt; G[Output];\\n    F --&gt; G;\\n```\\n\\n## Key Components\\n- **Canonical Models**: Define the standard data structures for users, messages, and events.\\n- **Data Transformer**: Converts data between plugin-specific formats and canonical formats.\\n- **Schema Registry**: Manages versioned schemas, facilitating schema upgrades and compatibility.\\n- **Audit Service**: Logs and monitors data transformations to ensure compliance and traceability.\\n\\n## Security Considerations\\n- **Data Encryption**: All data in transit and at rest is encrypted using industry-standard protocols.\\n- **Access Controls**: Strict access controls are enforced to ensure only authorized entities can perform data transformations.\\n- **Audit Logging**: Comprehensive logging of all data transformation activities for auditing and compliance verification.\\n\\n!!! warning\\n    Ensure that all access to the Canonical Service is secured and monitored to prevent unauthorized data access.\\n\",\n  \"api\": \"# API Reference\\n\\n## CanonicalService Class\\n\\n### Methods\\n\\n#### `normalize_user`\\nNormalizes user data from one plugin format to another.\\n\\n```python\\nasync def normalize_user(\\n    self, user_data: Dict[str, Any], source_plugin: str, target_plugin: str\\n) -&gt; CanonicalUser:\\n```\\n\\n- **Parameters**:\\n  - `user_data`: Dictionary containing user information.\\n  - `source_plugin`: The source plugin format.\\n  - `target_plugin`: The target plugin format.\\n\\n- **Returns**: A `CanonicalUser` object containing normalized user data.\\n\\n## SchemaRegistry Class\\n\\n### Methods\\n\\n#### `upsert`\\nInserts or updates a schema in the registry.\\n\\n```python\\ndef upsert(\\n    self, name: str, version: Version, schema_data: Dict[str, Any]\\n) -&gt; None:\\n```\\n\\n- **Parameters**:\\n  - `name`: The name of the schema.\\n  - `version`: The version of the schema.\\n  - `schema_data`: The schema data to be stored.\\n\\n- **Returns**: None\\n\",\n  \"config\": \"# Configuration Guide\\n\\n## Configuration Options\\n\\n| Option              | Description                                      | Default        |\\n|---------------------|--------------------------------------------------|----------------|\\n| `audit_level`       | The level of auditing for data transformations. | `AuditLevel.BASIC` |\\n| `schema_directory`  | Directory path for storing schema files.        | `schemas/`     |\\n\\n## Environment Variables\\n\\n- `CANONICAL_CONFIG_PATH`: Path to the configuration file.\\n- `CANONICAL_LOG_LEVEL`: The logging level for the service.\\n\\n!!! tip\\n    Ensure that configuration files are secured and only accessible to authorized personnel to maintain compliance.\\n\",\n  \"examples\": \"# Usage Examples\\n\\n=== \\\"Python\\\"\\n\\n    ```python\\n    from vivified.canonical.service import CanonicalService\\n    from vivified.audit.service import AuditService\\n    from vivified.policy.engine import PolicyEngine\\n\\n    audit_service = AuditService()\\n    policy_engine = PolicyEngine()\\n    canonical_service = CanonicalService(audit_service, policy_engine)\\n\\n    user_data = {\\n        'id': '1234',\\n        'username': 'jdoe',\\n        'email': 'jdoe@example.com'\\n    }\\n\\n    normalized_user = await canonical_service.normalize_user(user_data, 'pluginA', 'pluginB')\\n    print(normalized_user)\\n    ```\\n\\n=== \\\"curl\\\"\\n\\n    ```bash\\n    curl -X POST https://api.vivified.com/canonical/normalize_user \\\\\\n         -H \\\"Content-Type: application/json\\\" \\\\\\n         -d '{\\n             \\\"user_data\\\": {\\n                 \\\"id\\\": \\\"1234\\\",\\n                 \\\"username\\\": \\\"jdoe\\\",\\n                 \\\"email\\\": \\\"jdoe@example.com\\\"\\n             },\\n             \\\"source_plugin\\\": \\\"pluginA\\\",\\n             \\\"target_plugin\\\": \\\"pluginB\\\"\\n         }'\\n    ```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n- **Issue**: Schema not found.\\n  - **Solution**: Ensure that the schema is correctly registered in the schema registry.\\n\\n- **Issue**: Data transformation errors.\\n  - **Solution**: Check the input data format and ensure it matches the expected schema.\\n\\n!!! note\\n    For persistent issues, consult the service logs and verify the configuration settings.\"\n}\n</code></pre>"},{"location":"core/config/","title":"Config","text":"<pre><code>{\n    \"overview\": \"# Config Service Overview\\n\\nThe `config` service within the Vivified platform provides a robust solution for managing configuration data with an emphasis on security and compliance. This service supports hierarchical configuration management, encryption for sensitive data, and comprehensive audit logging, making it suitable for HIPAA-compliant environments.\\n\\n!!! note\\n    This service is designed to ensure data integrity and confidentiality, crucial for environments that require strict compliance with regulations such as HIPAA.\\n\\n## Architecture\\n\\n```mermaid\\ngraph LR\\n    A[Client] -- Request --&gt; B[Config Service]\\n    B -- Fetch/Store --&gt; C[(Database)]\\n    B -- Encrypt/Decrypt --&gt; D[Encryption Module]\\n```\\n\\n## Key Components\\n\\n- **Configuration Management**: Store and retrieve configuration settings.\\n- **Encryption**: Encrypt/decrypt sensitive configuration values using Fernet symmetric encryption.\\n- **Audit Logging**: Log configuration changes for auditing and compliance purposes.\",\n    \"api\": \"# Config Service API Reference\\n\\nThe Config Service API provides endpoints for managing configuration settings. Below are the available operations:\\n\\n!!! tip\\n    Use the API to programmatically manage configuration settings, ensuring automated processes can integrate with the config service.\\n\\n## Endpoints\\n\\nCurrently, there is no direct API documentation provided. Integration with this service occurs through the `ConfigService` class in the Python code.\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from config_service import ConfigService\\n    \\n    service = ConfigService(db_session=my_session, encryption_key=my_key)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    # No direct HTTP API available, use Python client\\n    ```\\n\\nFor more detailed usage, refer to the `service.py` file and its class methods.\",\n    \"config\": \"# Configuration Guide\\n\\nThe configuration system supports various options and settings. Below is a data table listing the configuration options:\\n\\n| Option        | Description                               | Type     | Required | Default    |\\n|---------------|-------------------------------------------|----------|----------|------------|\\n| `encryption_key` | Key for encrypting sensitive information | `string` | Yes      | N/A        |\\n| `db_session`  | Database session for persistence          | `object` | Yes      | N/A        |\\n\\n!!! warning\\n    Ensure the `encryption_key` is securely stored and managed. Loss of the key will make it impossible to decrypt sensitive configuration data.\\n\\n## Security Considerations\\n\\n- **Encryption**: Sensitive data is encrypted using Fernet symmetric encryption. Ensure that the encryption key is rotated periodically and stored securely.\\n- **Access Controls**: Limit access to configuration management to authorized personnel only.\\n- **Audit Logging**: Enable logging to track access and changes to configuration data.\",\n    \"examples\": \"# Usage Examples\\n\\nBelow are examples of using the Config Service to manage configuration settings.\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from config_service import ConfigService\\n    from sqlalchemy.ext.asyncio import AsyncSession\\n\\n    # Initialize service\\n    session = AsyncSession()\\n    service = ConfigService(db_session=session, encryption_key=\\\"my_secure_key\\\")\\n\\n    # Set a configuration item\\n    service.set_config(\\\"api_key\\\", \\\"12345\\\", is_sensitive=True)\\n\\n    # Get a configuration item\\n    api_key = service.get_config(\\\"api_key\\\")\\n    print(api_key)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    # No direct curl example available\\n    # Use the Python client to interact with the service\\n    ```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n- **Unable to Decrypt Data**: Ensure that the correct encryption key is being used. Verify that the environment variable `CONFIG_ENC_KEY` is set correctly if using environment-based keys.\\n- **Database Connectivity**: Check database connection settings and ensure the database is reachable.\\n\\n!!! tip\\n    Always verify that the encryption key and database credentials are correctly configured to prevent runtime issues.\"\n}\n</code></pre>"},{"location":"core/gateway/","title":"Gateway","text":"<pre><code>{\n  \"overview\": \"# Gateway Service Documentation\\n\\nThe **Gateway Service** serves as a critical component in the Vivified platform, providing secure external API access and proxy functionality. This service is designed to ensure compliance with HIPAA regulations while offering robust security features such as rate limiting and domain allowlisting.\\n\\n!!! note\\n    The Gateway Service is a HIPAA-compliant service, ensuring that all external communications adhere to the necessary privacy and security standards.\\n\\n## Architecture\\n\\n```mermaid\\ngraph LR\\n    A[Client Request] --&gt;|HTTP Method| B[Gateway Service]\\n    B --&gt;|Proxy Request| C[External API]\\n    B --&gt;|Audit Logs| D[Audit Service]\\n    B --&gt;|Policy Decision| E[Policy Engine]\\n```\\n\\n## Key Components\\n- **ProxyHandler**: Manages external API requests with security checks and rate limiting.\\n- **AuditService**: Logs all actions for compliance and monitoring.\\n- **PolicyEngine**: Evaluates requests against predefined security policies.\\n- **DomainAllowlist**: Controls which domains are accessible through the gateway.\\n\\n## Security Considerations\\n- All requests are logged and monitored by the `AuditService` to ensure compliance.\\n- The `PolicyEngine` enforces security policies on every request.\\n- Rate limiting is implemented to prevent abuse and ensure fair usage.\\n\\n!!! warning\\n    Ensure that all configurations comply with HIPAA rules to maintain data privacy and security.\",\n  \"api\": \"# API Reference\\n\\nThe Gateway Service provides an API for managing proxy requests.\\n\\n## ProxyRequest\\n\\n| Field      | Type          | Description                                  |\\n|------------|---------------|----------------------------------------------|\\n| `id`       | `str`         | Unique identifier for the request.           |\\n| `plugin_id`| `str`         | Identifier for the plugin making the request.|\\n| `method`   | `ProxyMethod` | HTTP method (GET, POST, etc.).               |\\n| `url`      | `HttpUrl`     | Target URL for the request.                  |\\n| `headers`  | `Dict[str,str]`| Custom headers to include in the request.   |\\n| `body`     | `Optional[bytes]`| Payload for the request.                   |\\n| `timeout`  | `int`         | Request timeout in seconds.                  |\\n| `retries`  | `int`         | Number of retry attempts.                    |\\n\\n## ProxyMethod\\n\\n| Method     | Description                        |\\n|------------|------------------------------------|\\n| `GET`      | Retrieve data from the server.     |\\n| `POST`     | Send data to the server.           |\\n| `PUT`      | Update data on the server.         |\\n| `DELETE`   | Remove data from the server.       |\\n| `PATCH`    | Partial update of data on the server. |\\n| `HEAD`     | Retrieve headers from the server.  |\\n| `OPTIONS`  | Describe communication options.    |\",\n  \"config\": \"# Configuration Guide\\n\\nThe Gateway Service can be configured using various parameters to control its behavior and ensure compliance.\\n\\n| Parameter          | Type      | Default | Description                                    |\\n|--------------------|-----------|---------|------------------------------------------------|\\n| `audit_service`    | `AuditService` | N/A     | Service for logging and monitoring.            |\\n| `policy_engine`    | `PolicyEngine` | N/A     | Service for evaluating security policies.     |\\n| `config_service`   | `Any`     | `None`  | Optional service for additional configurations.|\\n\\n!!! tip\\n    Customize the `DomainAllowlist` to restrict access to specific domains.\\n\\n### Rate Limiting\\n\\nThe Gateway Service implements rate limiting to manage request throughput and ensure compliance with HIPAA regulations.\\n\\n```yaml\\nrate_limits:\\n  default:\\n    requests_per_minute: 60\\n    burst_capacity: 10\\n```\\n\\n### Domain Allowlisting\\n\\n```yaml\\ndomain_allowlists:\\n  - domain: \\\"api.example.com\\\"\\n    allow: true\\n  - domain: \\\"*.trusted.com\\\"\\n    allow: true\\n```\\n\\n!!! note\\n    Ensure that the domains listed in `DomainAllowlist` comply with HIPAA privacy rules.\",\n  \"examples\": \"# Usage Examples\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from vivified.gateway.service import GatewayService\\n    from vivified.audit.service import AuditService\\n    from vivified.policy.engine import PolicyEngine\\n\\n    # Initialize services\\n    audit_service = AuditService()\\n    policy_engine = PolicyEngine()\\n\\n    # Create gateway service\\n    gateway_service = GatewayService(audit_service, policy_engine)\\n    \\n    # Make a proxy request\\n    proxy_request = ProxyRequest(\\n        plugin_id=\\\"plugin123\\\",\\n        method=ProxyMethod.GET,\\n        url=\\\"https://api.example.com/data\\\"\\n    )\\n    response = gateway_service.proxy_handler.handle_request(proxy_request)\\n    print(response)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X GET \\\"https://api.example.com/data\\\" \\\\\\n         -H \\\"Authorization: Bearer &lt;token&gt;\\\" \\\\\\n         -H \\\"Content-Type: application/json\\\"\\n    ```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n- **Timeout Errors**: Ensure the `timeout` parameter is set appropriately for long-running requests.\\n- **Blocked Domains**: Verify that the target domain is included in the `DomainAllowlist`.\\n\\n### Debugging Steps\\n\\n1. Check the audit logs for any recorded errors.\\n2. Verify the policy decisions using the `PolicyEngine` logs.\\n3. Ensure rate limits are properly configured and being adhered to.\\n\\n!!! warning\\n    Unauthorized attempts to access restricted domains will be logged and could result in service denial as part of security enforcement.\"\n}\n</code></pre>"},{"location":"core/identity/","title":"Identity & Auth","text":"<pre><code>{\n  \"overview\": \"# Identity Service Documentation\\n\\nThe **identity** service is a critical component of the Vivified platform, responsible for user authentication and identity management. This service is designed to be secure, scalable, and HIPAA-compliant, ensuring that sensitive information is protected according to regulatory standards.\\n\\n## Key Features\\n- JWT-based authentication\\n- Role-based access control\\n- Multi-factor authentication (MFA)\\n\\n!!! note\\n    This service is part of the Vivified Phase 2 deployment and includes FastAPI dependencies to protect endpoints.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[User] --&gt;|Requests Access| B[Identity Service];\\n    B --&gt;|Validates Credentials| C[JWT Token];\\n    C --&gt;|Returned to| A;\\n    A --&gt;|Uses JWT| D[Protected Resource];\\n```\\n\\n## Security Considerations\\n- Ensure that all JWT tokens are signed with a secure algorithm.\\n- Regularly rotate encryption keys and secrets.\\n- Implement MFA for enhanced security.\\n\\n!!! warning\\n    Never expose JWT tokens or secrets in client-side code.\\n\\n## Troubleshooting\\n\\n1. **Issue**: Users cannot log in.\\n   - **Solution**: Verify if the user account is active and the password is correct.\\n\\n2. **Issue**: JWT token expiration issues.\\n   - **Solution**: Check server time synchronization and token expiration settings.\\n\\n3. **Issue**: MFA not working as expected.\\n   - **Solution**: Ensure the MFA secret is correctly configured in the user profile.\\n\",\n  \"api\": \"# API Reference\\n\\n## Endpoints\\n\\n### Authentication\\n\\n- **POST /auth/login**\\n  - Description: Authenticate a user and return a JWT token.\\n  - Request Body:\\n    ```json\\n    {\\n      \\\"username\\\": \\\"string\\\",\\n      \\\"password\\\": \\\"string\\\"\\n    }\\n    ```\\n  - Response:\\n    ```json\\n    {\\n      \\\"token\\\": \\\"string\\\"\\n    }\\n    ```\\n\\n- **GET /auth/validate**\\n  - Description: Validate a provided JWT token.\\n  - Request Header:\\n    ```\\n    Authorization: Bearer &lt;token&gt;\\n    ```\\n  - Response:\\n    ```json\\n    {\\n      \\\"valid\\\": true\\n    }\\n    ```\\n\\n## Models\\n\\n### User\\n- **Fields**:\\n  - `id`: UUID\\n  - `username`: string\\n  - `email`: string\\n  - `password_hash`: string\\n  - `mfa_enabled`: boolean\\n  - `is_active`: boolean\\n\",\n  \"config\": \"# Configuration Guide\\n\\n## Environment Variables\\n\\n| Variable Name        | Description                     | Default Value |\\n|----------------------|---------------------------------|---------------|\\n| `JWT_SECRET`         | Secret key for JWT signing      | `change_me`   |\\n| `JWT_ALGORITHM`      | Algorithm for JWT signing       | `HS256`       |\\n| `DB_CONNECTION`      | Database connection string      | `postgresql://user:pass@localhost/db` |\\n| `MFA_REQUIRED`       | Enforce MFA for all users       | `false`       |\\n\\n!!! tip\\n    Ensure all environment variables are set in a secure manner and not hard-coded in your application code.\\n\",\n  \"examples\": \"# Usage Examples\\n\\n=== \\\"Python\\\"\\n\\n    ```python\\n    import requests\\n\\n    response = requests.post('https://api.vivified.com/auth/login', json={\\n        'username': 'user@example.com',\\n        'password': 'securepassword'\\n    })\\n    token = response.json()['token']\\n    headers = {'Authorization': f'Bearer {token}'}\\n    validation_response = requests.get('https://api.vivified.com/auth/validate', headers=headers)\\n    print(validation_response.json())\\n    ```\\n\\n=== \\\"curl\\\"\\n\\n    ```bash\\n    curl -X POST https://api.vivified.com/auth/login \\\\\\n         -H \\\"Content-Type: application/json\\\" \\\\\\n         -d '{\\\"username\\\": \\\"user@example.com\\\", \\\"password\\\": \\\"securepassword\\\"}'\\n\\n    token=\\\"&lt;JWT_TOKEN&gt;\\\"\\n\\n    curl -X GET https://api.vivified.com/auth/validate \\\\\\n         -H \\\"Authorization: Bearer $token\\\"\\n    ```\\n\"\n}\n</code></pre>"},{"location":"core/messaging/","title":"Messaging","text":"<pre><code>{\n  \"overview\": \"## Messaging Service Overview\\n\\nThe messaging service is an integral component of the Vivified platform that facilitates inter-plugin communication with strict adherence to HIPAA compliance. It ensures secure and efficient data exchange across various platform modules.\\n\\n!!! note\\n    This service uses a canonical message format and supports multiple message types, including events, requests, responses, and notifications.\\n\\n### Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[Messaging Service] --&gt;|Sends Message| B[Event Bus];\\n    B --&gt; C{Broker}\\n    C --&gt;|Dispatch| D[Subscriber Plugins];\\n    C --&gt;|Audit| E[Audit Service];\\n    C --&gt;|Policy Check| F[Policy Engine];\\n```\\n\\n### Key Components\\n- **MessagingService**: The main service managing message dispatch and receipt.\\n- **EventBus**: Abstracts the broker for message publishing and subscribing, supporting various backends like NATS, Redis, or in-memory.\\n- **AuditService**: Ensures all message interactions are logged for compliance and security auditing.\\n- **PolicyEngine**: Evaluates policies to enforce data privacy and security measures.\\n\\n### Security Considerations\\n- All messages are audited to ensure compliance with HIPAA regulations.\\n- Data classifications such as PHI and PII are enforced to protect sensitive information.\\n- The policy engine ensures that all data exchanges comply with predefined security policies.\\n\\n!!! warning\\n    Ensure that the messaging service is deployed in a secure and isolated environment to prevent unauthorized access to sensitive data.\\n\\n## Troubleshooting\\n\\n1. **Message Delivery Failures**\\n   - Check network connectivity and broker availability.\\n   - Ensure correct broker configuration in the environment settings.\\n\\n2. **Policy Decision Denials**\\n   - Review policy rules in the PolicyEngine for accuracy and relevancy.\\n   - Validate user permissions and roles against policy requirements.\",\n  \"api\": \"## Messaging Service API Reference\\n\\n### MessagingService\\n\\n- `__init__(self, audit_service: AuditService, policy_engine: PolicyEngine)`: Initializes the messaging service with audit and policy components.\\n- `start(self)`: Starts the messaging service for handling inter-plugin communication.\\n\\n### Message Model\\n\\n| Attribute        | Type               | Description                         |\\n|------------------|--------------------|-------------------------------------|\\n| `id`             | `str`              | Unique identifier for the message.  |\\n| `message_type`   | `MessageType`      | Type of the message (e.g., event).  |\\n| `priority`       | `MessagePriority`  | Priority level of the message.      |\\n\\n### MessageType Enum\\n- `EVENT`: Represents an event message.\\n- `REQUEST`: Represents a request message.\\n- `RESPONSE`: Represents a response message.\\n- `NOTIFICATION`: Represents a notification message.\\n\\n### MessagePriority Enum\\n- `LOW`, `NORMAL`, `HIGH`, `CRITICAL`: Priority levels.\\n\\n### DataClassification Enum\\n- `PUBLIC`, `INTERNAL`, `CONFIDENTIAL`, `PHI`, `PII`: Data classification levels.\",\n  \"config\": \"## Configuration Guide\\n\\nThe messaging service can be configured using environment variables or configuration files. Below are the key configuration options:\\n\\n| Option                  | Description                                        | Default        |\\n|-------------------------|----------------------------------------------------|----------------|\\n| `EVENT_BUS_BACKEND`     | Backend for the event bus (`nats`, `redis`, `memory`). | `memory`       |\\n| `LOG_LEVEL`             | Logging level for the service (`DEBUG`, `INFO`).   | `INFO`         |\\n\\nTo configure the event bus backend to use Redis, set the environment variable:\\n\\n```bash\\nexport EVENT_BUS_BACKEND=redis\\n```\\n\\n!!! tip\\n    Test your configuration changes in a development environment before applying them to production.\",\n  \"examples\": \"## Usage Examples\\n\\n=== \\\"Python\\\"\\n\\n    ```python\\n    from vivified.messaging.service import MessagingService\\n    from vivified.audit.service import AuditService\\n    from vivified.policy.engine import PolicyEngine\\n\\n    audit_service = AuditService()\\n    policy_engine = PolicyEngine()\\n    messaging_service = MessagingService(audit_service, policy_engine)\\n\\n    async def start_service():\\n        await messaging_service.start()\\n    ```\\n\\n=== \\\"curl\\\"\\n\\n    ```bash\\n    # Example command to check service status\\n    curl -X GET http://localhost:8000/status\\n    ```\\n\\nThese examples demonstrate how to initialize and start the messaging service using Python and how to interact with it via command-line tools like curl.\"\n}\n</code></pre>"},{"location":"core/monitoring/","title":"Monitoring","text":"<pre><code>{\n  \"overview\": \"# Monitoring Service Documentation\\n\\n## Overview\\n\\nThe **Monitoring Service** for the Vivified platform is designed to provide real-time metrics and monitoring capabilities to ensure system reliability and compliance with HIPAA regulations. This service collects, aggregates, and exposes metrics using Prometheus, making it easier to monitor the health and performance of the platform.\\n\\n!!! note\\n    This service is compliant with HIPAA regulations, ensuring that all monitoring activities respect the privacy and security of protected health information (PHI).\\n\\n## Architecture\\n\\nThe Monitoring Service is built using the FastAPI framework and integrates with Prometheus for metrics collection.\\n\\n```mermaid\\ngraph TD;\\n    A[User Request] --&gt;|API Call| B[FastAPI Application];\\n    B --&gt; C{Metrics Collection};\\n    C --&gt;|Record Duration| D[Histogram: request_duration];\\n    C --&gt;|Track Plugins| E[Gauge: active_plugins];\\n    C --&gt;|Count Notifications| F[Counter: notifications_sends_total];\\n    C --&gt;|Count Sent Notifications| G[Counter: notifications_sent_total];\\n    C --&gt;|Count Failed Notifications| H[Counter: notifications_failed_total];\\n    D --&gt;|Expose Metrics| I[Prometheus];\\n    E --&gt; I;\\n    F --&gt; I;\\n    G --&gt; I;\\n    H --&gt; I;\\n```\\n\\n## Security Considerations\\n\\n!!! warning\\n    Ensure that the monitoring endpoints are secured and accessible only to authorized personnel. Exposing these endpoints publicly could lead to unauthorized access to sensitive operational data.\\n\\n- **Encryption**: All data in transit should be encrypted using TLS to prevent interception.\\n- **Authentication**: Implement authentication mechanisms to restrict access to metrics.\\n- **Audit Logs**: Maintain logs of who accesses the metrics and when, to comply with HIPAA auditing requirements.\",\n  \"api\": \"# API Reference\\n\\n## Endpoints\\n\\n### `/metrics`\\n\\nThis endpoint exposes all collected metrics in a format compatible with Prometheus.\\n\\n!!! tip\\n    Use authentication headers to access this endpoint securely.\\n\\n=== \\\"Python\\\"\\n\\n    ```python\\n    import requests\\n\\n    response = requests.get('https://your-domain.com/metrics', headers={'Authorization': 'Bearer YOUR_TOKEN'})\\n    print(response.text)\\n    ```\\n\\n=== \\\"curl\\\"\\n\\n    ```bash\\n    curl -H \\\"Authorization: Bearer YOUR_TOKEN\\\" https://your-domain.com/metrics\\n    ```\\n\\n## Metrics Details\\n\\n- **`vivified_request_duration_seconds`**: Histogram tracking the duration of requests.\\n- **`vivified_active_plugins`**: Gauge showing the number of active plugins.\\n- **`vivified_notifications_sends_total`**: Counter for total notification requests received.\\n- **`vivified_notifications_sent_total`**: Counter for notifications marked sent.\\n- **`vivified_notifications_failed_total`**: Counter for notifications marked as failed.\",\n  \"config\": \"# Configuration Guide\\n\\n## Configuration Options\\n\\n| Option                   | Description                          | Default |\\n|--------------------------|--------------------------------------|---------|\\n| `PROMETHEUS_ENDPOINT`    | URL for accessing Prometheus metrics | `/metrics`|\\n| `AUTH_TOKEN`             | Token for securing the metrics endpoint | None    |\\n| `ENABLE_TLS`             | Boolean to enable/disable TLS        | `True`  |\\n\\n!!! note\\n    Ensure that the `PROMETHEUS_ENDPOINT` is secured and not exposed to unauthorized users.\",\n  \"examples\": \"# Usage Examples\\n\\n## Collecting Metrics\\n\\nTo collect metrics from the Monitoring Service, you can use the following examples:\\n\\n=== \\\"Python\\\"\\n\\n    ```python\\n    import requests\\n\\n    def fetch_metrics():\\n        url = 'https://your-domain.com/metrics'\\n        headers = {'Authorization': 'Bearer YOUR_TOKEN'}\\n        response = requests.get(url, headers=headers)\\n        if response.status_code == 200:\\n            return response.text\\n        else:\\n            raise Exception('Failed to fetch metrics')\\n    ```\\n\\n=== \\\"curl\\\"\\n\\n    ```bash\\n    curl -H \\\"Authorization: Bearer YOUR_TOKEN\\\" https://your-domain.com/metrics\\n    ```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n- **Unauthorized Access**\\n  - Ensure your `AUTH_TOKEN` is correctly configured and passed in the request header.\\n  - Verify that the endpoint is not publicly accessible without proper authentication.\\n\\n- **Metrics Not Updating**\\n  - Check the application logs for any errors in metrics collection.\\n  - Ensure that the Prometheus server is correctly scraping the `/metrics` endpoint.\\n\\n!!! tip\\n    Regularly audit your configurations and access logs to maintain HIPAA compliance.\"\n}\n</code></pre>"},{"location":"core/notifications/","title":"Notifications","text":"<pre><code>{\n  \"overview\": \"# Notifications Service Documentation\\n\\nThe **notifications** service in the Vivified platform is designed to manage and dispatch notifications while ensuring compliance with HIPAA standards. This service is crucial for maintaining communication within the platform, orchestrating notifications, and managing the lifecycle of notification events.\\n\\n## Key Responsibilities\\n\\n- **Accept Notification Requests**: The service accepts requests to send notifications and publishes canonical events for further processing.\\n- **Subscribe and Manage Events**: It subscribes to `NotificationSent` events and maintains an inbox.\\n- **Expose Settings**: Provides simple settings that are currently in-memory but are designed to be pluggable with Redis/Postgres in the future.\\n- **Metrics and Auditing**: Emits Prometheus metrics for monitoring and audit events for compliance and traceability.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[NotificationRequest] --&gt;|Publish Event| B[MessagingService];\\n    B --&gt; C[PolicyEngine];\\n    C --&gt; D[AuditService];\\n    B --&gt; E[NotificationSent Event];\\n    E --&gt; F[InboxItem Management];\\n    D --&gt; G[Prometheus Metrics];\\n```\\n\\n!!! note\\n    This service is a proof of concept and currently uses in-memory storage for settings and inbox items. Future enhancements will include integration with Redis or Postgres.\\n\",\n  \"api\": \"# API Reference\\n\\nThe notifications service currently does not expose a REST API directly but interacts through event-driven mechanisms and internal service calls. Below are the primary data models utilized:\\n\\n## NotificationRequest\\n- `notification_id`: Unique identifier for the notification.\\n- `title`: Optional title of the notification.\\n- `body`: Main content of the notification.\\n- `priority`: Priority level of the notification (`low`, `normal`, `high`, `critical`).\\n- `channel`: Optional communication channel.\\n- `targets`: List of target recipients.\\n- `metadata`: Additional metadata.\\n\\n## NotificationSent\\n- `event_type`: Type of the event, default is `NotificationSent`.\\n- `notification_id`: Identifier for the sent notification.\\n- `plugin`: The plugin used to send the notification.\\n- `timestamp`: Time the notification was sent.\\n- `status`: Current status of the notification (`queued`, `sent`, `partial`, `failed`).\\n- `details`: Additional details about the notification event.\\n\\n## Example Event Subscription\\n=== \\\"Python\\\"\\n    ```python\\n    from core.messaging.service import MessagingService\\n    \\n    def handle_notification_sent(event):\\n        # Process notification sent event\\n        print(f\\\"Notification {event.notification_id} sent with status {event.status}\\\")\\n    \\n    messaging_service = MessagingService()\\n    messaging_service.subscribe(\\\"NotificationSent\\\", handle_notification_sent)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X POST \\\\\\n      http://localhost:8080/events/subscribe \\\\\\n      -H \\\"Content-Type: application/json\\\" \\\\\\n      -d '{\\\"event_type\\\": \\\"NotificationSent\\\", \\\"callback_url\\\": \\\"http://myservice/handle\\\"}'\\n    ```\\n\",\n  \"config\": \"# Configuration Guide\\n\\nThe following table outlines the configuration options available for the notifications service:\\n\\n| Configuration Option     | Description                                      | Default Value |\\n|--------------------------|--------------------------------------------------|---------------|\\n| `inbox_storage`          | Determines the type of storage for the inbox     | `in-memory`   |\\n| `metrics_enabled`        | Enables or disables Prometheus metrics emission  | `true`        |\\n| `audit_level`            | Sets the level of audit logging                  | `normal`      |\\n| `default_notification_channel` | Default channel for sending notifications | `email`       |\\n\\n!!! warning\\n    Ensure that configuration changes adhere to HIPAA compliance standards, especially when dealing with sensitive data.\\n\\n## Security Considerations\\n\\n- **Data Encryption**: All notifications containing PHI (Protected Health Information) must be encrypted in transit and at rest.\\n- **Access Control**: Ensure that only authorized personnel have access to the configuration and the ability to send notifications.\\n- **Audit Logs**: Maintain comprehensive audit logs of all notification events to comply with HIPAA regulations.\\n\",\n  \"examples\": \"# Usage Examples\\n\\n## Sending a Notification\\n\\n=== \\\"Python\\\"\\n```python\\nfrom core.messaging.service import MessagingService\\nfrom .models import NotificationRequest, NotificationPriority\\n\\n# Create a notification request\\nnotification = NotificationRequest(\\n    notification_id=\\\"12345\\\",\\n    title=\\\"Urgent Update\\\",\\n    body=\\\"Please review the latest policy changes.\\\",\\n    priority=NotificationPriority.high,\\n    targets=[\\\"user1@example.com\\\", \\\"user2@example.com\\\"]\\n)\\n\\n# Send the notification\\nmessaging_service = MessagingService()\\nmessaging_service.publish_event(\\\"NotificationRequest\\\", notification.dict())\\n```\\n\\n=== \\\"curl\\\"\\n```bash\\ncurl -X POST \\\\\\n  http://localhost:8080/notifications/send \\\\\\n  -H \\\"Content-Type: application/json\\\" \\\\\\n  -d '{\\n        \\\"notification_id\\\": \\\"12345\\\",\\n        \\\"title\\\": \\\"Urgent Update\\\",\\n        \\\"body\\\": \\\"Please review the latest policy changes.\\\",\\n        \\\"priority\\\": \\\"high\\\",\\n        \\\"targets\\\": [\\\"user1@example.com\\\", \\\"user2@example.com\\\"]\\n      }'\\n```\\n\\n## Troubleshooting\\n\\n### Common Issues\\n\\n1. **Notifications not being sent**\\n   - Verify if the messaging service is correctly configured and active.\\n   - Check logs for any errors related to policy engine decisions.\\n\\n2. **High latency in notification delivery**\\n   - Review Prometheus metrics to identify bottlenecks.\\n   - Consider increasing resources or optimizing the notification processing logic.\\n\\n### Logs and Debugging\\n\\n- Check the logs generated by the AuditService for any anomalies or unauthorized access attempts.\\n\\n!!! tip\\n    Regularly review and optimize the notification processing logic to handle high loads efficiently and maintain HIPAA compliance.\"\n}\n</code></pre>"},{"location":"core/overview/","title":"Overview","text":"<ul> <li> <p>:material-shield-check:{ .lg .middle } Core Services</p> <p>Canonical, Storage, Messaging, Gateway \u2014 secure and modular</p> </li> <li> <p>:material-puzzle:{ .lg .middle } Modular Design</p> <p>Plugin-first architecture with well-defined contracts</p> </li> <li> <p>:material-insights:{ .lg .middle } Observability</p> <p>Audit logs, metrics, and health endpoints across services</p> </li> </ul> <p>Admin-First Design</p> <p>All core service operations must be available through the Admin Console. No CLI-only controls.</p> <p>PHI/PII Handling</p> <p>Core services are built to minimize PHI exposure. Use classification and redaction in storage and messages.</p> <p>Network Exposure</p> <p>Do not expose internal core endpoints directly to the public internet. Use the Gateway for external access.</p>"},{"location":"core/overview/#services-at-a-glance","title":"Services at a Glance","text":"Service Purpose Exposed Interfaces HIPAA canonical Normalize and transform data gRPC/REST, plugins Compliant storage Encrypted PHI/PII storage REST API, SDK Compliant messaging Inter-plugin event bus Pub/Sub API Compliant gateway External proxy &amp; filtering HTTP(S) ingress Compliant <ul> <li> <p>:material-code-tags-check:{ .lg .middle } Stable SDKs</p> <p>Python and Node.js SDKs for service access</p> </li> <li> <p>:material-security:{ .lg .middle } Audit &amp; Retention</p> <p>7-year retention for audit logs, tamper-proof append-only store</p> </li> </ul>"},{"location":"core/overview/#high-level-architecture","title":"High-level Architecture","text":"<p><code>mermaid flowchart LR   AdminUI[Admin Console] --&gt;|Admin API| API[Admin API Gateway]   API --&gt; Canonical[Canonical Service]   API --&gt; Storage[Storage Service]   API --&gt; Messaging[Messaging Service]   Gateway[External Gateway] --&gt;|Proxied Requests| API   Storage --&gt;|Encrypted| Vault[(Key Vault)]</code></p>"},{"location":"core/overview/#getting-service-status","title":"Getting Service Status","text":"PythonNode.jscurl <pre><code># (1) Simple health check against Admin API\nimport requests\nr = requests.get('https://localhost:8443/health')\nprint(r.json())\n</code></pre> <pre><code>// (1) Node health check\nconst fetch = require('node-fetch')\nfetch('https://localhost:8443/health').then(r =&gt; r.json()).then(console.log)\n</code></pre> <pre><code># (1) Use curl to check overall platform health\ncurl -sS https://localhost:8443/health | jq\n</code></pre> <ol> <li>Requests the unified health endpoint which aggregates service health</li> </ol>"},{"location":"core/overview/#service-contracts-short","title":"Service Contracts (short)","text":"<ul> <li>Canonical: accepts plugin-specific payloads, returns normalized canonical model</li> <li>Storage: uses AES-256 at rest, per-tenant keying supported</li> <li>Messaging: event bus supports routing, filters, and PII-safe payloads</li> <li>Gateway: domain allowlists, request/response transformations</li> </ul>"},{"location":"core/overview/#glossary","title":"Glossary","text":"CanonicalUser Standard user model across plugins Audit Log Immutable, append-only record of data and operational events"},{"location":"core/overview/#operational-checklist","title":"Operational Checklist","text":"<ul> <li> Ensure audit.retention_years &gt;= 7</li> <li> Verify encryption keys stored in Key Vault</li> <li> Regularly rotate keys and review RBAC</li> </ul> Debugging Tips <p>Use Ctrl+Shift+I to open browser devtools for Admin UI troubleshooting. Check network requests to /api/* endpoints.</p>"},{"location":"core/plugin_manager/","title":"Plugin Manager","text":"<pre><code>{\n  \"overview\": \"# Plugin Manager Service\\n\\nThe `plugin_manager` service within the Vivified platform is a critical component responsible for managing the lifecycle of plugins. This service ensures plugins are registered, secure, and healthy, aligning with HIPAA compliance requirements. It provides enhanced functionality through security validation and health monitoring.\\n\\n## Key Features\\n\\n- **Security Validation:** Ensures plugins meet stringent security configurations.\\n- **Health Monitoring:** Regularly checks the health of plugins and initiates recovery if necessary.\\n- **Lifecycle Management:** Handles registration, activation, and deactivation of plugins.\\n\\n!!! note\\n    The `plugin_manager` service is designed to integrate seamlessly with other components of the Vivified platform, ensuring consistent and secure plugin operations.\\n\\n## Architecture Overview\\n\\n```mermaid\\ngraph TD;\\n    A[Plugin Registration] --&gt; B[Security Validation];\\n    B --&gt; C[Health Monitoring];\\n    C --&gt; D[Lifecycle Management];\\n    B --&gt; E{Compliance Check};\\n    E --&gt;|Pass| F[Activate Plugin];\\n    E --&gt;|Fail| G[Notify Admin];\\n    D --&gt; H[Audit Logging];\\n```\\n\\nThis diagram illustrates the flow from plugin registration through security validation and health monitoring, ensuring compliance and operational integrity.\",\n  \"api\": \"# API Reference\\n\\n## Plugin Registration Endpoint\\n\\nThe plugin manager provides a RESTful API for plugin registration.\\n\\n### Endpoint: `/register`\\n\\n- **Method:** POST\\n- **Description:** Registers a new plugin with the platform.\\n\\n#### Request Parameters\\n\\n| Parameter | Type   | Description                |\\n|-----------|--------|----------------------------|\\n| manifest  | JSON   | Plugin manifest details    |\\n\\n#### Responses\\n\\n- **200 OK:** Plugin registered successfully.\\n- **400 Bad Request:** Invalid manifest data.\\n\\n!!! tip\\n    Ensure the plugin manifest includes all required fields and adheres to the security configurations specified in the platform policies.\",\n  \"config\": \"# Configuration Guide\\n\\n## SecurityValidator Configuration\\n\\nThe `SecurityValidator` class ensures plugins conform to security policies.\\n\\n### Security Configurations\\n\\n| Configuration           | Description                                          |\\n|-------------------------|------------------------------------------------------|\\n| authentication_required | Ensures the plugin requires authentication           |\\n| network_isolation       | Ensures the plugin operates in an isolated network   |\\n| data_classification     | Ensures the plugin data is classified appropriately  |\\n\\n!!! warning\\n    Plugins must not have any blocked domains or dangerous traits as per the security policies.\\n\\n## HealthMonitor Configuration\\n\\n| Configuration      | Description                                           |\\n|--------------------|-------------------------------------------------------|\\n| check_interval     | Interval (seconds) between health checks              |\\n| failure_threshold  | Number of consecutive failures before marking unhealthy |\\n\\nThese configurations ensure the continuous monitoring and health of plugins.\",\n  \"examples\": \"# Usage Examples\\n\\n## Registering a Plugin\\n\\nUse the following examples to register a plugin with the Vivified platform.\\n\\n=== \\\"Python\\\"\\n\\n```python\\nimport requests\\n\\nmanifest = {\\n    \\\"id\\\": \\\"plugin-123\\\",\\n    \\\"name\\\": \\\"Example Plugin\\\",\\n    \\\"version\\\": \\\"1.0.0\\\",\\n    \\\"description\\\": \\\"A sample plugin\\\",\\n    \\\"contracts\\\": [],\\n    \\\"traits\\\": [\\\"hipaa_authorized\\\"],\\n    \\\"dependencies\\\": [],\\n    \\\"allowed_domains\\\": [\\\"example.com\\\"],\\n    \\\"security\\\": {\\n        \\\"authentication_required\\\": True,\\n        \\\"network_isolation\\\": True,\\n        \\\"data_classification\\\": \\\"confidential\\\"\\n    }\\n}\\n\\nresponse = requests.post(\\\"https://vivified-platform/api/register\\\", json=manifest)\\nprint(response.status_code)\\n```\\n\\n=== \\\"curl\\\"\\n\\n```bash\\ncurl -X POST https://vivified-platform/api/register \\\\\\n    -H \\\"Content-Type: application/json\\\" \\\\\\n    -d '{\\n        \\\"id\\\": \\\"plugin-123\\\",\\n        \\\"name\\\": \\\"Example Plugin\\\",\\n        \\\"version\\\": \\\"1.0.0\\\",\\n        \\\"description\\\": \\\"A sample plugin\\\",\\n        \\\"contracts\\\": [],\\n        \\\"traits\\\": [\\\"hipaa_authorized\\\"],\\n        \\\"dependencies\\\": [],\\n        \\\"allowed_domains\\\": [\\\"example.com\\\"],\\n        \\\"security\\\": {\\n            \\\"authentication_required\\\": true,\\n            \\\"network_isolation\\\": true,\\n            \\\"data_classification\\\": \\\"confidential\\\"\\n        }\\n    }'\\n```\\n\\nThese examples demonstrate how to register a plugin with the required security attributes.\",\n  \"security_considerations\": \"# Security Considerations\\n\\nThe `plugin_manager` service incorporates several security measures to ensure HIPAA compliance:\\n\\n- **Blocked Domains:** Utilizes a list of blocked domains to prevent unauthorized access.\\n- **Dangerous Traits:** Identifies and restricts plugins with traits such as `admin`, `system`, or `root`.\\n- **PHI Handling:** Ensures all plugins handling Protected Health Information (PHI) are properly authorized and audited.\\n\\n!!! important\\n    Always verify the security configurations of a plugin before registration to ensure it adheres to HIPAA and organizational policies.\",\n  \"troubleshooting\": \"# Troubleshooting\\n\\n## Common Issues\\n\\n### Plugin Registration Fails\\n\\n- **Cause:** Invalid or incomplete manifest data.\\n- **Solution:** Verify all required fields in the manifest are provided and correctly formatted.\\n\\n### Security Validation Errors\\n\\n- **Cause:** Plugin contains blocked domains or unauthorized traits.\\n- **Solution:** Review the security policies and adjust the plugin configuration accordingly.\\n\\n### Health Monitoring Alerts\\n\\n- **Cause:** Plugin is marked as unhealthy due to consecutive failures.\\n- **Solution:** Investigate plugin logs for errors and ensure network connectivity and resource availability.\\n\\n!!! note\\n    For persistent issues, consult the platform's audit logs and reach out to the support team with detailed error messages for further assistance.\"\n}\n</code></pre>"},{"location":"core/policy/","title":"Policy Engine","text":"<pre><code>{\n  \"overview\": \"# Policy Service Overview\\n\\nThe **Policy Service** in the Vivified platform is designed to provide a robust, trait-based policy engine that enforces hierarchical access control, data classification, and plugin interaction policies. This service plays a critical role in maintaining compliance with HIPAA regulations by ensuring that access to sensitive data is closely monitored and controlled.\\n\\n!!! note\\n    The Policy Service is an integral part of the Vivified platform's security infrastructure, providing fine-grained access control and data protection.\\n\\n## Key Features\\n- **Hierarchical Trait-Based Access Control**: Enforces access policies based on user roles and capabilities.\\n- **Data Classification Enforcement**: Ensures compliance with data access policies.\\n- **Plugin Interaction Policies**: Manages how plugins can interact with the system.\\n- **UI Feature Gating**: Controls access to specific UI features based on user roles.\\n- **Comprehensive Audit Logging**: Logs all policy decisions for audit and compliance purposes.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD\\n    A[Policy Request] --&gt;|Evaluates| B[Policy Engine]\\n    B --&gt;|Decision| C[Policy Decision]\\n    B --&gt;|Logs| D[Audit Log]\\n    B --&gt;|Enforces| E[Data Classification]\\n    B --&gt;|Controls| F[UI Features]\\n```\\n\\n## Security Considerations\\nThe Policy Service is designed with security at its core, aligning with HIPAA requirements:\\n\\n- **Audit Logging**: Every decision made by the policy engine is logged for audit purposes.\\n- **Access Control**: Implements strict access control measures to prevent unauthorized data access.\\n- **Data Sanitization**: Provides mechanisms to sanitize sensitive data before exposure.\\n\\n!!! warning\\n    Ensure that all API requests to the Policy Service are authenticated and encrypted to prevent unauthorized access or data breaches.\\n\\n## Troubleshooting\\n\\nIf you encounter issues with the Policy Service:\\n\\n- **Check Logs**: Review the audit logs to identify any unauthorized access attempts or errors in policy evaluation.\\n- **Verify Configuration**: Ensure that the trait registry and policy configurations are correctly set up and loaded.\\n\\n!!! tip\\n    Regularly update the trait definitions and policy rules to adapt to new security requirements and compliance regulations.\\n\",\n  \"api\": \"# Policy API Reference\\n\\nThe Policy Service API provides endpoints for evaluating access control policies and managing trait-based rules.\\n\\n## Endpoints\\n\\n### Evaluate Policy\\n- **Endpoint**: `/api/policy/evaluate`\\n- **Method**: `POST`\\n- **Description**: Evaluates a policy request based on provided traits and context.\\n\\n#### Request Parameters\\n\\n| Parameter | Type   | Description |\\n|-----------|--------|-------------|\\n| `user_id` | string | Unique identifier for the user making the request. |\\n| `context` | string | Context for policy evaluation (e.g., `USER_ACTION`). |\\n| `traits`  | list   | List of traits associated with the request. |\\n\\n#### Response\\n\\n- **200 OK**: Returns the policy decision (`allow`, `deny`, `sanitize`).\\n\\n!!! example \\\"Python\\\"\\n    ```python\\n    import requests\\n    response = requests.post('https://api.vivified.com/policy/evaluate', json={\\n        'user_id': '12345',\\n        'context': 'USER_ACTION',\\n        'traits': ['role:admin', 'capability:read']\\n    })\\n    print(response.json())\\n    ```\\n\\n!!! example \\\"curl\\\"\\n    ```bash\\n    curl -X POST https://api.vivified.com/policy/evaluate \\\\\\n    -H \\\"Content-Type: application/json\\\" \\\\\\n    -d '{\\\"user_id\\\": \\\"12345\\\", \\\"context\\\": \\\"USER_ACTION\\\", \\\"traits\\\": [\\\"role:admin\\\", \\\"capability:read\\\"]}'\\n    ```\\n\",\n  \"config\": \"# Configuration Guide\\n\\nThe Policy Service configuration involves setting up the trait registry and defining policy rules.\\n\\n## Trait Registry\\n\\nThe trait registry classifies and validates traits used in policy evaluation.\\n\\n| Option          | Description                                |\\n|-----------------|--------------------------------------------|\\n| `ROLE`          | Defines user roles and permissions.        |\\n| `CAPABILITY`    | Specifies user or plugin capabilities.     |\\n| `DATA_ACCESS`   | Manages access to classified data.         |\\n| `UI_FEATURE`    | Controls UI elements and feature access.   |\\n| `PLUGIN_TYPE`   | Categorizes plugins for interaction policies. |\\n| `SECURITY`      | Security-related traits and enforcement.   |\\n| `COMPLIANCE`    | Compliance requirements for data access.   |\\n\\n## Policy Rules\\n\\nDefine rules based on traits to enforce access control and data compliance.\\n\\n- **Rule Format**: JSON objects specifying trait conditions and resulting policy decisions.\\n\\n## Logging Configuration\\n\\nEnsure logging is enabled to maintain an audit trail of policy decisions.\\n\\n```yaml\\nlogging:\\n  level: DEBUG\\n  handlers: [console, file]\\n```\\n\\n!!! note\\n    Regularly review and update the trait registry and policy rules to maintain compliance with evolving regulations.\\n\",\n  \"examples\": \"# Usage Examples\\n\\n## Evaluating Policy Requests\\n\\nThe following examples demonstrate how to evaluate policy requests using the Policy Service API.\\n\\n=== \\\"Python\\\"\\n    ```python\\n    import requests\\n    \\n    def evaluate_policy(user_id, context, traits):\\n        url = 'https://api.vivified.com/policy/evaluate'\\n        payload = {\\n            'user_id': user_id,\\n            'context': context,\\n            'traits': traits\\n        }\\n        response = requests.post(url, json=payload)\\n        return response.json()\\n\\n    decision = evaluate_policy('12345', 'USER_ACTION', ['role:admin', 'data_access:confidential'])\\n    print('Policy Decision:', decision)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X POST https://api.vivified.com/policy/evaluate \\\\\\n    -H \\\"Content-Type: application/json\\\" \\\\\\n    -d '{\\\"user_id\\\": \\\"12345\\\", \\\"context\\\": \\\"USER_ACTION\\\", \\\"traits\\\": [\\\"role:admin\\\", \\\"data_access:confidential\\\"]}'\\n    ```\\n\\n!!! tip\\n    Use the `SANITIZE` decision to allow access while ensuring sensitive data is removed from responses.\\n\"\n}\n</code></pre>"},{"location":"core/security/","title":"Security","text":"<pre><code>{\n  \"overview\": \"# Security Service Documentation\\n\\n## Overview\\nThe **Security Service** in the Vivified platform provides robust mechanisms to ensure data confidentiality, integrity, and compliance with HIPAA regulations. It encompasses TLS configuration for secure communications and encryption utilities for protecting sensitive data such as PHI and PII.\\n\\n!!! note\\n    The security service is designed to be HIPAA-compliant, ensuring that all data transactions and storage adhere to stringent security requirements.\\n\\n## Architecture\\nThe security service consists of two main components:\\n\\n- **TLS Configuration**: Establishes secure communication channels using SSL/TLS protocols.\\n- **Encryption Utilities**: Provides encryption and decryption functionalities for sensitive data.\\n\\n```mermaid\\ngraph TD;\\n    A[TLS Configuration] --&gt; B[SSL Context Creation];\\n    C[Encryption Utilities] --&gt; D[AES-256-GCM Encryption];\\n    D --&gt; E[Data Protection];\\n```\\n\\n\",\n  \"api\": \"# API Reference\\n\\n## TLS Configuration\\nThe TLS configuration is handled via the `tls_config.py` file, which creates a secure SSL context for server communications.\\n\\n## Encryption Utilities\\nThe `encryption.py` file provides an API for encrypting and decrypting data using AES-256-GCM.\\n\\n### Methods\\n\\n- `create_tls_context(cert_dir: str) -&gt; ssl.SSLContext`: Creates and returns an SSL context configured with the specified certificates.\\n- `HIPAAEncryption.encrypt(data: Dict, associated_data: str) -&gt; Tuple[str, str]`: Encrypts data with associated data for context.\\n- `HIPAAEncryption.decrypt(ciphertext: str, associated_data: str) -&gt; Dict`: Decrypts data using the associated context data.\\n\\n\",\n  \"config\": \"# Configuration Guide\\n\\n## TLS Configuration\\nThe TLS setup is critical for secure communication between clients and servers. The `tls_config.py` file includes the following configuration options:\\n\\n| Option       | Description                                |\\n|--------------|--------------------------------------------|\\n| cert_dir     | Directory path for certificate files       |\\n| ca_cert      | Path to the CA certificate file            |\\n| server_cert  | Path to the server certificate file        |\\n| server_key   | Path to the server key file                |\\n\\n!!! warning\\n    Ensure that the certificate and key files are kept secure and only accessible by authorized personnel.\\n\\n## Encryption Configuration\\nThe encryption utilities use AES-256-GCM for data encryption. Ensure that:\\n\\n- Keys are securely stored and managed.\\n- Key rotation policies are implemented using a KMS or HSM for long-term storage.\\n\\n!!! tip\\n    Regularly update and rotate encryption keys to maintain security.\\n\\n\",\n  \"examples\": \"# Usage Examples\\n\\n## TLS Context Creation\\nThe following example demonstrates how to create an SSL context for secure communications:\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from tls_config import create_tls_context\\n    context = create_tls_context(cert_dir=\\\"/path/to/certs\\\")\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl --cert /path/to/core.crt --key /path/to/core.key https://secure.example.com\\n    ```\\n\\n## Data Encryption and Decryption\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from encryption import HIPAAEncryption\\n\\n    data = {\\\"patient_id\\\": \\\"12345\\\", \\\"data\\\": \\\"sensitive information\\\"}\\n    encryption_instance = HIPAAEncryption()\\n    ciphertext, tag = encryption_instance.encrypt(data, \\\"12345\\\")\\n    decrypted_data = encryption_instance.decrypt(ciphertext, \\\"12345\\\")\\n    ```\\n\\n## Security Considerations\\n- Ensure all data is transmitted over secure channels.\\n- Use strong, random keys for encryption.\\n- Regularly audit and update security configurations.\\n\\n## Troubleshooting\\n- **Problem**: Failure to load certificates.\\n  **Solution**: Verify the certificate paths and file permissions.\\n\\n- **Problem**: Decryption errors.\\n  **Solution**: Ensure the correct keys and associated data are used for decryption.\\n\\n- **Problem**: SSL handshake failures.\\n  **Solution**: Check SSL/TLS versions and cipher configurations for compatibility.\\n\\n!!! note\\n    For further assistance, refer to the official documentation or contact support.\\n\\n\"\n}\n</code></pre>"},{"location":"core/storage/","title":"Storage","text":"<pre><code>{\n  \"overview\": \"\\n# Overview\\n\\nThe **Vivified Storage Service** is a core component of the Vivified platform, providing robust, HIPAA-compliant storage capabilities for sensitive data, including PHI (Protected Health Information) and PII (Personally Identifiable Information). This service ensures data security through encryption, comprehensive audit logging, and strict retention policies.\\n\\n## Key Features\\n- **Automatic Encryption**: All sensitive data is encrypted using advanced cryptographic techniques.\\n- **Data Classification**: Supports classification levels such as PUBLIC, INTERNAL, CONFIDENTIAL, PHI, and PII.\\n- **Audit Logging**: Detailed logging of all access and modifications to data.\\n- **HIPAA-compliant Retention Policies**: Supports standard retention periods to meet HIPAA requirements.\\n- **Multiple Storage Providers**: Integrates with Filesystem, S3, and potentially Azure.\\n\\n!!! note\\n    This service is designed to be fully compliant with HIPAA regulations, ensuring secure handling of sensitive healthcare data.\\n\\n## Architecture\\n\\n```mermaid\\ngraph TD;\\n    A[Client Application] --&gt;|API Request| B[Storage Service];\\n    B --&gt;|Encrypts Data| C[Storage Provider];\\n    C --&gt; D{Filesystem};\\n    C --&gt; E{S3};\\n    C --&gt; F{Azure};\\n    B --&gt;|Audit Log| G[Audit Service];\\n    B --&gt;|Policy Check| H[Policy Engine];\\n```\\n\\n!!! tip\\n    Use the appropriate StorageProvider for your infrastructure needs, such as S3 for cloud storage or Filesystem for on-premise solutions.\\n\",\n  \"api\": \"\\n# API Reference\\n\\n## StorageService Class\\n\\n### Methods\\n\\n#### `store_object(storage_object: StorageObject) -&gt; StorageMetadata`\\nStores an object and returns the updated metadata.\\n\\n#### `retrieve_object(object_key: str) -&gt; Optional[StorageObject]`\\nRetrieves an object by its key.\\n\\n#### `delete_object(object_key: str) -&gt; bool`\\nDeletes an object by its key.\\n\\n#### `list_objects(query: StorageQuery) -&gt; List[StorageMetadata]`\\nLists objects matching the query.\\n\\n!!! warning\\n    Ensure that all API requests are authenticated and authorized to maintain data integrity and security.\\n\",\n  \"config\": \"\\n# Configuration Guide\\n\\n## Storage Configuration Options\\n\\n| Option              | Description                                                   | Default       |\\n|---------------------|---------------------------------------------------------------|---------------|\\n| `storage_provider`  | The storage backend to use (e.g., Filesystem, S3, Azure).    | `filesystem`  |\\n| `encryption_key`    | Master key for encryption of sensitive data.                  |               |\\n| `retention_policy`  | Data retention policy (e.g., SHORT_TERM, HIPAA_STANDARD).     | `HIPAA_STANDARD` |\\n\\n!!! note\\n    Ensure that the encryption key is kept secure and not exposed in code or logs.\\n\",\n  \"examples\": \"\\n# Usage Examples\\n\\n## Store an Object\\n\\n=== \\\"Python\\\"\\n    ```python\\n    from vivified.storage import StorageService, StorageObject\\n\\n    storage_service = StorageService()\\n    obj = StorageObject(data=\\\"Sensitive Data\\\", classification=\\\"PHI\\\")\\n    metadata = await storage_service.store_object(obj)\\n    print(metadata)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X POST \\\\\\n      -H \\\"Authorization: Bearer &lt;token&gt;\\\" \\\\\\n      -d '{\\\"data\\\": \\\"Sensitive Data\\\", \\\"classification\\\": \\\"PHI\\\"}' \\\\\\n      https://api.vivified.com/storage/store\\n    ```\\n\\n## Retrieve an Object\\n\\n=== \\\"Python\\\"\\n    ```python\\n    metadata = await storage_service.retrieve_object(\\\"object_key\\\")\\n    print(metadata)\\n    ```\\n\\n=== \\\"curl\\\"\\n    ```bash\\n    curl -X GET \\\\\\n      -H \\\"Authorization: Bearer &lt;token&gt;\\\" \\\\\\n      https://api.vivified.com/storage/retrieve?object_key=object_key\\n    ```\\n\",\n  \"security\": \"\\n# Security Considerations\\n\\n- **Encryption**: All PHI/PII data is encrypted using AES 128 with HMAC for integrity.\\n- **Audit Logging**: Every action is logged with details including user, timestamp, and action type.\\n- **Access Control**: Ensure that the Policy Engine is configured to enforce trait-based access control.\\n- **Data Integrity**: Use consistent hashing to verify data integrity during storage and retrieval.\\n\\n!!! warning\\n    Never share your encryption keys or tokens. Regularly rotate keys and tokens to enhance security.\\n\",\n  \"troubleshooting\": \"\\n# Troubleshooting\\n\\n## Common Issues\\n\\n### Encryption Errors\\n- **Symptom**: \\\"Encryption key not found.\\\"\\n- **Solution**: Ensure the `encryption_key` is configured correctly in the service settings.\\n\\n### Access Denied\\n- **Symptom**: \\\"403 Forbidden\\\"\\n- **Solution**: Verify that the API token is valid and has the necessary permissions.\\n\\n### Data Retrieval Issues\\n- **Symptom**: \\\"Object not found\\\"\\n- **Solution**: Check if the object key is correct and the object exists in the storage.\\n\\n!!! tip\\n    Enable debug logging to get more detailed error messages that can assist in troubleshooting.\\n\"\n}\n</code></pre>"},{"location":"core/three-lanes/","title":"Three-Lane Communication Model","text":"<p>The platform enforces three supervised lanes for all data movement: Canonical (events), Operator (internal RPC), and Proxy (egress). Plugins run in isolated containers with no direct database or network access; every lane terminates in Core, where policy, audit, redaction, rate limits, and allowlists are applied. When safety cannot be proven, the action is blocked (fail-safe).</p>"},{"location":"core/three-lanes/#actors-guards","title":"Actors &amp; Guards","text":"<ul> <li>Plugin runtime: isolated container, no outbound network; authenticates to Core with a unique token.</li> <li>Core Gateway: entry point for Operator calls (<code>/gateway/{target_plugin}/{operation}</code>).</li> <li>Canonical Engine: normalized event hub (<code>core/canonical/*</code>) with validation and policy.</li> <li>Proxy: the only egress path; enforces domain/path allowlists and TLS; blocks IP literals/localhost.</li> <li>Policy Engine: evaluates traits, roles, data classification, and operation allowlists.</li> <li>Audit Service: structured logs with <code>trace_id</code> and redacted PHI/PII; every decision/action recorded.</li> <li>Storage Service: AES\u2011256 at rest; PHI tagging and retention metadata.</li> <li>Identity: derives claims/traits for policy and trait\u2011gated UI.</li> </ul>"},{"location":"core/three-lanes/#why-three-lanes","title":"Why Three Lanes","text":"<ul> <li>Canonical abstracts data semantics and decouples producers/consumers with strong validation and policy.</li> <li>Operator provides tightly scoped, synchronous actions without exposing network primitives.</li> <li>Proxy centralizes egress, secret handling, and compliance controls to reduce exfiltration risk.</li> </ul>"},{"location":"core/three-lanes/#visuals","title":"Visuals","text":"<p>```mermaid flowchart TB   %% Three-Lane overview with wrapped labels   classDef box fill:#eef5ff,stroke:#4c6ef5,color:#222,stroke-width:1px   classDef edge stroke:#888,color:#444</p> <p>subgraph Plugin[Plugin Container\\n(no outbound network)]     P1[\"LLM Plugin\\nclassify=PHI\\ntrace_id=...\\nrefs not raw PHI\"]:::box   end</p> <p>CoreGW[\"Core Gateway\\n(Operator RPC)\"]:::box   Canonical[\"Canonical Engine\\n(schema + policy + audit)\"]:::box   Proxy[\"Core Proxy\\n(allowlist + TLS + secrets)\"]:::box   Vectorizer[\"Vectorizer Plugin\\n(Embed op)\"]:::box</p> <p>%% Edges (use short phrases to avoid overflow)   P1 -- \"Operator: Embed\" \u2192 CoreGW   CoreGW -- \"dispatch\" \u2192 Vectorizer   P1 -- \"Canonical: DocumentSummarized\" \u2192 Canonical   P1 -- \"Proxy: chat completions\" \u2192 Proxy</p> <p>style Plugin fill:#f8fbff,stroke:#aac6ff,stroke-width:1px   class P1,CoreGW,Canonical,Proxy,Vectorizer box ```</p> <p>```mermaid flowchart TB   %% Default backends and fail-safe fallbacks   classDef box fill:#f4fff4,stroke:#2e7d32,color:#222,stroke-width:1px   classDef warn fill:#fff8e1,stroke:#f9a825,color:#222,stroke-width:1px</p> <p>subgraph Core[Core Services]     DB[(Postgres\\npostgresql+asyncpg)]:::box     RAG[(Redis\\nredis://localhost:6379/0)]:::box   end</p> <p>subgraph Fallbacks[Graceful Fallbacks]     MemDB[(SQLite in-tests\\nTEST_DB_URL or in-memory)]:::warn     MemRAG[(In-memory RAG\\nif Redis unreachable)]:::warn   end</p> <p>Core \u2192 Fallbacks   DB -. tests only .-&gt; MemDB   RAG -. on failure .-&gt; MemRAG ```</p>"},{"location":"core/three-lanes/#journey-a-piece-of-data-inside-the-llm-plugin","title":"Journey: A Piece of Data Inside the LLM Plugin","text":"<p>Imagine a PHI\u2011bearing text snippet the LLM plugin must summarize and then notify others.</p> <p>1) Born in the LLM plugin - The plugin tags payload <code>classification=[\"phi\"]</code>, sets <code>tenant_id</code>, and creates a <code>trace_id</code>. - It constructs requests carrying identity (plugin token \u2192 plugin id + traits), classification tags, policy context (actor, tenant, purpose, operation), and observability metadata (<code>trace_id</code>, <code>span_id</code>, timestamps, idempotency key).</p> <p>2) Proxy Lane: call an external LLM safely - The plugin cannot open sockets. It builds an <code>EgressRequest</code> describing target domain/path, method, and payload. No scheme, no IP literals, no localhost; no plugin-supplied Authorization. - Core Proxy enforces allowlists, injects secrets from vault, enforces TLS 1.3+, applies rate limits, redacts and audits.</p> <p>3) Canonical Lane: publish the normalized result - The plugin wraps the result in a normalized canonical event (e.g., <code>DocumentSummarized</code>) including schema version, tenant, classification tags, references/hashes (not raw PHI). - Canonical validates schema, enforces policy (e.g., <code>handles_phi</code>), audits, persists with encryption, and fans-out only to authorized consumers.</p> <p>4) Operator Lane: invoke another plugin synchronously - For embeddings, the LLM plugin calls <code>POST /gateway/vectorizer/Embed</code> with a compact reference or redacted text. - Gateway authenticates, checks operation allowlist, applies SSRF guards, evaluates policy and rate limits, audits, and dispatches to the vectorizer plugin.</p> <p>5) Secondary events and notifications - Emit <code>DocumentEmbedded</code> canonical event for indexing. - Notifications rules evaluate events and may emit a <code>NotificationRequest</code> to audiences by trait (e.g., <code>sales</code>). Any external fan\u2011out uses Proxy with allowlists and secret injection.</p> <p>6) Admin Console visibility (trait\u2011aware) - Diagnostics shows lane health and provider status. - Audit views show lineage: Proxy call \u2192 Canonical events \u2192 Operator call. Payloads remain redacted; classification is visible; everything linked by <code>trace_id</code>.</p>"},{"location":"core/three-lanes/#example-payloads","title":"Example Payloads","text":"<p>Below are reference envelopes. Fields are indicative; adapt to your SDK structures. Avoid including raw PHI\u2014prefer references/hashes and classification metadata.</p>"},{"location":"core/three-lanes/#proxy-lane-egressrequest-request","title":"Proxy Lane \u2014 EgressRequest (request)","text":"<pre><code>{\n  \"trace_id\": \"6b3c8a10-6d3f-4f1e-9d41-9e5a7a12c0c7\",\n  \"span_id\": \"08a9c3b2d8f1a7e2\",\n  \"idempotency_key\": \"llm:complete:doc-9f3f:v1\",\n  \"tenant_id\": \"tenant_abc\",\n  \"actor\": { \"type\": \"plugin\", \"id\": \"plugin.llm\" },\n  \"actor_traits\": [\"handles_phi\", \"ai_client\"],\n  \"classification\": [\"phi\"],\n  \"purpose\": \"clinical_summary\",\n  \"policy_context\": {\n    \"operation\": \"proxy.egress\",\n    \"requested_scopes\": [\"egress:api.openai.com:/v1/chat/completions:POST\"],\n    \"data_tags\": [\"phi\"]\n  },\n  \"target\": {\n    \"domain\": \"api.openai.com\",\n    \"path\": \"/v1/chat/completions\",\n    \"method\": \"POST\"\n  },\n  \"headers\": {\n    \"content-type\": \"application/json\"\n  },\n  \"body\": {\n    \"model\": \"gpt-4o-mini\",\n    \"messages\": [\n      { \"role\": \"system\", \"content\": \"You are a helpful assistant.\" },\n      { \"role\": \"user\", \"content_ref\": \"urn:doc:9f3f#segment:summary-input\" }\n    ],\n    \"temperature\": 0.2\n  },\n  \"constraints\": { \"require_tls\": true, \"disallow_ip_literals\": true }\n}\n</code></pre>"},{"location":"core/three-lanes/#proxy-lane-egressresponse-response","title":"Proxy Lane \u2014 EgressResponse (response)","text":"<pre><code>{\n  \"trace_id\": \"6b3c8a10-6d3f-4f1e-9d41-9e5a7a12c0c7\",\n  \"request_id\": \"req_01HZXK2FQ0R2M3WZQ8\",\n  \"policy_decision\": {\n    \"allowed\": true,\n    \"rule\": \"allow:openai.com:completions\",\n    \"redactions\": [\"headers.authorization\", \"body.choices[].message.content\"]\n  },\n  \"rate_limit\": { \"domain\": \"api.openai.com\", \"remaining\": 149, \"reset_ms\": 42000 },\n  \"egress\": {\n    \"status\": 200,\n    \"duration_ms\": 512,\n    \"response_headers\": { \"content-type\": \"application/json\" },\n    \"response_body\": {\n      \"id\": \"chatcmpl-abc123\",\n      \"choices\": [\n        { \"index\": 0, \"message_ref\": \"urn:doc:9f3f#segment:summary-output\", \"finish_reason\": \"stop\" }\n      ]\n    }\n  },\n  \"audit_id\": \"aud_01HZXK39W8HK3Z9XPK\"\n}\n</code></pre>"},{"location":"core/three-lanes/#canonical-lane-event-documentsummarized","title":"Canonical Lane \u2014 Event (DocumentSummarized)","text":"<pre><code>{\n  \"trace_id\": \"6b3c8a10-6d3f-4f1e-9d41-9e5a7a12c0c7\",\n  \"tenant_id\": \"tenant_abc\",\n  \"producer\": { \"type\": \"plugin\", \"id\": \"plugin.llm\" },\n  \"producer_traits\": [\"handles_phi\"],\n  \"classification\": [\"phi\"],\n  \"topic\": \"canonical.documents.summarized\",\n  \"schema\": { \"name\": \"DocumentSummarized\", \"version\": \"1.2.0\" },\n  \"occured_at\": \"2025-09-29T09:32:41.120Z\",\n  \"data\": {\n    \"document_ref\": \"urn:doc:9f3f\",\n    \"summary_ref\": \"urn:doc:9f3f#segment:summary-output\",\n    \"summary_hash\": \"sha256-3d9212...\",\n    \"language\": \"en\",\n    \"model\": \"gpt-4o-mini\",\n    \"tokens_used\": { \"prompt\": 1024, \"completion\": 128 }\n  },\n  \"policy_context\": { \"operation\": \"canonical.emit\", \"data_tags\": [\"phi\"] }\n}\n</code></pre>"},{"location":"core/three-lanes/#operator-lane-gateway-rpc-request-to-vectorizerembed","title":"Operator Lane \u2014 Gateway RPC (request) to Vectorizer.Embed","text":"<pre><code>{\n  \"trace_id\": \"6b3c8a10-6d3f-4f1e-9d41-9e5a7a12c0c7\",\n  \"span_id\": \"7e2c1a0b4f9d3c8a\",\n  \"tenant_id\": \"tenant_abc\",\n  \"caller\": { \"type\": \"plugin\", \"id\": \"plugin.llm\" },\n  \"caller_traits\": [\"handles_phi\", \"ai_client\"],\n  \"classification\": [\"phi\"],\n  \"operation\": \"vectorizer.Embed\",\n  \"params\": {\n    \"content_ref\": \"urn:doc:9f3f#segment:summary-output\",\n    \"normalize\": true,\n    \"dims\": 1536\n  },\n  \"policy_context\": {\n    \"operation\": \"gateway.invoke\",\n    \"requested_scopes\": [\"rpc:vectorizer.Embed\"],\n    \"data_tags\": [\"phi\"]\n  }\n}\n</code></pre>"},{"location":"core/three-lanes/#operator-lane-gateway-rpc-response","title":"Operator Lane \u2014 Gateway RPC (response)","text":"<pre><code>{\n  \"trace_id\": \"6b3c8a10-6d3f-4f1e-9d41-9e5a7a12c0c7\",\n  \"policy_decision\": {\n    \"allowed\": true,\n    \"rule\": \"allow:rpc:vectorizer.Embed\",\n    \"redactions\": []\n  },\n  \"result\": {\n    \"embedding_ref\": \"urn:vec:9f3f#v1\",\n    \"dims\": 1536,\n    \"vector_checksum\": \"sha256-91ba77...\",\n    \"duration_ms\": 34\n  },\n  \"audit_id\": \"aud_01HZXK4VJCCEV5Q2V8\"\n}\n</code></pre>"},{"location":"core/three-lanes/#failure-modes-blocking-conditions","title":"Failure Modes (blocking conditions)","text":"<ul> <li>Proxy: domain not allowlisted; IP literal/localhost; non\u2011TLS; forbidden path; missing secrets; rate\u2011limit exceeded \u2192 request denied and audited.</li> <li>Canonical: schema mismatch; missing/invalid classification; producer lacks <code>handles_phi</code>; tenant/policy violation \u2192 event rejected and audited.</li> <li>Operator: operation not allowlisted; SSRF\u2011unsafe parameters (scheme present, non\u2011internal host); caller lacks traits/permissions; rate\u2011limit exceeded \u2192 call denied and audited.</li> </ul>"},{"location":"core/three-lanes/#practical-tips-for-llm-plugin-authors","title":"Practical Tips for LLM Plugin Authors","text":"<ul> <li>Always tag payloads with correct classification (<code>phi</code>, <code>pii</code>, <code>confidential</code>) and <code>tenant_id</code>.</li> <li>Use Canonical for sharing results/events; minimize PHI content in events; prefer references/hashes.</li> <li>Use Operator for internal, synchronous helpers; pass references instead of raw PHI when possible.</li> <li>Use Proxy for any external API; never embed credentials or full URLs; request domains/paths that are pre\u2011allowlisted.</li> <li>Keep <code>trace_id</code> consistent across lanes to preserve end\u2011to\u2011end lineage.</li> </ul>"},{"location":"core/three-lanes/#admin-console-parity","title":"Admin Console Parity","text":"<ul> <li>Expose <code>/auth/me</code> for trait discovery; Admin Console hides/shows features accordingly.</li> <li>Provide <code>/admin/ui-config</code> and <code>/admin/user/traits</code> for feature flags and trait mapping.</li> <li>Diagnostics: health, provider status, and lane metrics; all trait\u2011aware and least\u2011privilege by default.</li> </ul>"},{"location":"docs/admin-console/","title":"Admin console","text":"<ul> <li> <p>:material-dashboard:{ .lg .middle } Admin Console</p> </li> <li> <p>:material-settings:{ .lg .middle } Settings &amp; Configuration</p> </li> <li> <p>:material-dashboard_customize:{ .lg .middle } Plugin Management</p> </li> </ul> <p>Accessibility</p> <p>All features must be accessible via the Admin Console per the Accessibility/Dyslexia Mandate.</p> <p>No CLI-only Features</p> <p>Operator actions, including plugin enablement and storage management, must be available via the UI.</p> <p>Admin Privileges</p> <p>Admin accounts grant wide access. Use MFA and role separation for production.</p>"},{"location":"docs/admin-console/#entry-points","title":"Entry points","text":"Area Path Purpose Dashboard /admin/ui System overview Plugins /admin/ui/plugins Register &amp; manage plugins Storage Browser /admin/ui/storage Browse encrypted objects Settings /admin/ui/settings Global configuration <p><code>mermaid graph LR     Operator --&gt; AdminUI     AdminUI --&gt; API[Admin API]     AdminUI --&gt; Auth[Auth Service]</code> </p>"},{"location":"docs/admin-console/#common-tasks","title":"Common tasks","text":"<ul> <li> Add a plugin</li> <li> Configure plugin credentials</li> <li> Run smoke tests</li> </ul>"},{"location":"docs/admin-console/#adding-a-plugin","title":"Adding a plugin","text":"PythonNode.jscurl <pre><code># (1) Example: create plugin registration payload\npayload = {\"id\":\"com.example.plugin\",\"name\":\"Example\"}\nrequests.post('https://localhost:8443/api/v1/plugins/register', json=payload)\n</code></pre> <pre><code>// (1) Trigger plugin register via JS client (pseudo)\nclient.plugins.register({ id: 'com.example.plugin', name: 'Example' })\n</code></pre> <pre><code># (1) cURL register plugin\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"id\":\"com.example.plugin\",\"name\":\"Example\"}' https://localhost:8443/api/v1/plugins/register\n</code></pre> <ol> <li>Use Admin API to register plugins; the Admin Console surfaces registration in UI</li> </ol> Provider Setup Wizard <p>Use Provider Setup Wizard components shipped by plugins to guide operators through credential entry and initial tests.</p>"},{"location":"docs/admin-console/#storage-browser","title":"Storage Browser","text":"<ul> <li>Browse encrypted objects</li> <li>Search by tags, traits, and time ranges</li> </ul> Filter Description Notes tag PHI/PII / custom tags Auto-applied by storage classifier timeframe Date range Useful for retention checks <p>Helpful</p> <p>Use the built-in outbound smoke tests for plugin connectivity checks.</p>"},{"location":"docs/api-reference/","title":"Api reference","text":"<ul> <li> <p>:material-api:{ .lg .middle } Admin API</p> </li> <li> <p>:material-key:{ .lg .middle } Authentication &amp; RBAC</p> </li> <li> <p>:material-history-edu:{ .lg .middle } Audit &amp; Logs</p> </li> </ul> <p>API Usage</p> <p>Use the Admin API for all management operations. Service-to-service interactions should use scoped service tokens.</p> <p>Rate Limits</p> <p>Admin API enforces rate limits for management endpoints. Monitor via /metrics.</p> <p>Credentials</p> <p>Use short-lived tokens and rotate them regularly.</p>"},{"location":"docs/api-reference/#authentication-authorization","title":"Authentication &amp; Authorization","text":"Mechanism Purpose Recommended OAuth2 / OIDC User auth &amp; SSO \u2705 Service tokens Service-to-service Scoped, short-lived RBAC Role-based access Enforce least privilege <p><code>mermaid sequenceDiagram     participant Client     participant AdminAPI     participant Auth     Client-&gt;&gt;AdminAPI: Request resource     AdminAPI-&gt;&gt;Auth: Validate token     Auth--&gt;&gt;AdminAPI: Token valid     AdminAPI--&gt;&gt;Client: Return resource</code> </p>"},{"location":"docs/api-reference/#key-endpoints-examples","title":"Key endpoints (examples)","text":"Endpoint Method Purpose Auth /api/v1/health GET Health check None or token /api/v1/plugins/register POST Register plugin Admin token /api/v1/storage/objects POST Store object Scoped token /api/v1/messaging/publish POST Publish message Scoped token"},{"location":"docs/api-reference/#example-get-health","title":"Example: get health","text":"PythonNode.jscurl <pre><code># (1) Healthcheck\nimport requests\nr = requests.get('https://localhost:8443/api/v1/health')\nprint(r.json())\n</code></pre> <pre><code>// (1) Healthcheck using fetch\nconst res = await fetch('https://localhost:8443/api/v1/health')\nconst data = await res.json()\nconsole.log(data)\n</code></pre> <pre><code># (1) cURL healthcheck\ncurl -k https://localhost:8443/api/v1/health\n</code></pre> <ol> <li>Health endpoint accessible for smoke tests</li> </ol> Versioning <p>API is versioned under /api/v1/. Backwards-incompatible changes will be released as /api/v2/.</p>"},{"location":"docs/api-reference/#error-responses","title":"Error responses","text":"Status Meaning Action 400 Bad Request Validate payload 401 Unauthorized Refresh token 403 Forbidden Check RBAC roles 500 Server Error Check logs &amp; audit <p>Sensitive Data</p> <p>Do not surface PHI in error messages. Errors should reference an audit ID for operator lookup.</p>"},{"location":"docs/configuration/","title":"Configuration","text":"<ul> <li> <p>:material-settings:{ .lg .middle } Configuration Reference</p> </li> <li> <p>:material-key:{ .lg .middle } Secrets &amp; Keys</p> </li> <li> <p>:material-tune:{ .lg .middle } Tuning &amp; Retention</p> </li> </ul> <p>Centralized Config</p> <p>Use the Admin Console to manage most runtime configuration. For infra-level config use environment variables and secrets management.</p> <p>Defaults</p> <p>Reasonable defaults are provided but must be reviewed for compliance before production use.</p> <p>Critical</p> <p>Never store production secrets in plaintext or checked-in files.</p>"},{"location":"docs/configuration/#global-configuration-options","title":"Global configuration options","text":"Key Type Default Description ADMIN_API_PORT int 8443 Port for Admin API STORAGE_KMS_KEY string \"\" KMS key identifier for storage encryption AUDIT_RETENTION_DAYS int 2555 Audit retention in days (7 years) METRICS_RETENTION_DAYS int 90 Metrics retention <p><code>mermaid graph LR     Config[(Config Store)] --&gt; AdminAPI     AdminAPI --&gt; Services[Core Services]     Services --&gt; Storage</code> </p>"},{"location":"docs/configuration/#service-specific-configuration","title":"Service-specific configuration","text":""},{"location":"docs/configuration/#canonical","title":"canonical","text":"Key Type Default Description canonical.normalizers list [\"case\",\"trim\"] Active normalizers canonical.transformers list [] Custom transformers registered by plugins"},{"location":"docs/configuration/#storage","title":"storage","text":"Key Type Default Description storage.encryption.kms_key string \"\" KMS key identifier storage.retention.days int 2555 Retention in days storage.classification.auto_tag bool true Auto-tag data for PHI/PII"},{"location":"docs/configuration/#messaging","title":"messaging","text":"Key Type Default Description messaging.broker.url string \"\" Broker connection string messaging.dlq.retention_days int 30 DLQ retention"},{"location":"docs/configuration/#gateway","title":"gateway","text":"Key Type Default Description gateway.rate_limit.qps int 10 Default QPS per client gateway.allowlist.domains list [] Allowed external domains PythonNode.jscurl <pre><code># (1) Load configuration from env with defaults\nimport os\nADMIN_API_PORT = int(os.getenv('ADMIN_API_PORT', '8443'))\nSTORAGE_KMS_KEY = os.getenv('STORAGE_KMS_KEY', '')\n</code></pre> <pre><code>// (1) Example Node config loader (pseudo)\nconst ADMIN_API_PORT = parseInt(process.env.ADMIN_API_PORT || '8443')\nconst STORAGE_KMS_KEY = process.env.STORAGE_KMS_KEY || ''\n</code></pre> <pre><code># (1) Retrieve current config via Admin API\ncurl -H \"Authorization: Bearer $ADMIN_TOKEN\" https://localhost:8443/api/v1/config\n</code></pre> <ol> <li>Configuration uses env vars and Admin API for dynamic settings</li> </ol> Overriding defaults <p>Prefer Admin Console overrides for runtime tuning; reserve env vars for infra-level secrets.</p>"},{"location":"docs/configuration/#configuration-validation","title":"Configuration validation","text":"<ul> <li>The platform validates configuration at startup and surfaces errors in logs and the Admin Console.</li> </ul> Validation Behavior Action Missing required key Startup fail Provide key or secret Invalid type Startup fail Correct type <p>Pro Tip</p> <p>Use CI to run a config lint step that loads configs with test values to catch type errors early.</p>"},{"location":"docs/getting-started/","title":"Getting started","text":"<ul> <li> <p>:material-rocket:{ .lg .middle } Quick Start</p> <p>Start the Vivified platform locally and access the Admin Console</p> </li> <li> <p>:material-rocket-launch:{ .lg .middle } Local CI Parity</p> <p>Run exactly what CI runs before every push</p> </li> <li> <p>:material-account-circle:{ .lg .middle } User Setup</p> <p>Create admin users and initial configuration</p> </li> </ul> <p>Quick Tip</p> <p>Create a Python 3.11 virtual environment and pin versions to match CI for deterministic behavior.</p> <p>Implementation Note</p> <p>The local CI parity steps mirror CI and must be run before pushing. This prevents the \"THIS MANY ERRORS\" flood.</p> <p>Security Warning</p> <p>Do not expose sensitive credentials in examples. Use environment variables and a secrets manager.</p>"},{"location":"docs/getting-started/#table-of-contents","title":"Table of contents","text":"<ul> <li>Prerequisites</li> <li>Local Preflight (recommended)</li> <li>Start Services (dev)</li> <li>Admin Console Access</li> <li>Next steps</li> </ul>"},{"location":"docs/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11</li> <li>Node 20.x (optional for Admin UIs)</li> <li>Docker (for local containerized runs)</li> </ul> <p>Environment Note</p> <p>Use Ctrl+C / Ctrl+V to copy commands into terminals. Use a dedicated developer machine or container for sensitive PHI/PII testing.</p> Why Python 3.11? <p>Python 3.11 matches CI. Using different Python versions causes subtle mypy/flake8 mismatches.</p>"},{"location":"docs/getting-started/#local-preflight-recommended","title":"Local Preflight (recommended)","text":"<p>Follow these steps exactly as CI runs them. This ensures parity and keeps branch protection green.</p> Step Command Purpose Status Create venv python3.11 -m venv .venv Isolate dependencies Required Install deps pip install -r core/requirements.txt   black==25.9.0 ... Match CI pinned tools Required Lint black --check core/; flake8 core/ Code style &amp; quality Required Typecheck mypy --config-file mypy.ini core/ Static typing Required Tests PYTHONPATH=$PWD pytest -q Unit/integration tests Required <p>Success</p> <p>If all checks pass locally you have strong confidence CI will pass. Use pre-commit to automate this.</p> PythonNode.jscurl <pre><code># (1) Create and activate venv\npython3.11 -m venv .venv  # (2)\n. .venv/bin/activate\n# (3) Install dependencies\npip install -r core/requirements.txt \\\n  black==25.9.0 flake8==7.3.0 mypy==1.18.2 sqlalchemy==2.0.23 \\\n  pytest pytest-cov pytest-asyncio\n</code></pre> <pre><code>// (1) Optional: ensure Node 20.x or lts/* is used\n// (2) In core/ui and core/admin_ui\n// npm ci &amp;&amp; npm run build\n</code></pre> <pre><code># (1) Example healthcheck against Admin API\ncurl -H \"Authorization: Bearer $ADMIN_TOKEN\" https://localhost:8443/admin/health\n</code></pre> <ol> <li>Use Python 3.11 for parity</li> <li>Pinned tool versions mirror CI</li> <li>Tests must pass locally before pushing</li> </ol>"},{"location":"docs/getting-started/#start-services-development","title":"Start Services (development)","text":"<p>Follow this checklist to start services locally (non-production).</p> <ul> <li> Create venv and install deps</li> <li> Run database migrations (if using local DB)</li> <li> Start core services via docker-compose or make targets</li> </ul> PythonNode.jscurl <pre><code># (1) Run a lightweight dev server (example)\nexport FLASK_ENV=development\nPYTHONPATH=$PWD python -m core.app\n</code></pre> <pre><code>// (1) Start Admin UI in dev mode\ncd core/admin_ui\nnpm ci\nnpm run dev\n</code></pre> <pre><code># (1) Smoke test API\ncurl -k https://localhost:8443/api/v1/health\n</code></pre> <ol> <li>Lightweight dev server for API</li> <li>Admin UI dev server</li> <li>Quick smoke test endpoint</li> </ol> <p><code>mermaid graph LR     Dev[Developer Machine] --&gt;|Run preflight| LocalCI[Local CI Parity]     LocalCI --&gt;|Start| API[Admin API]     LocalCI --&gt; UI[Admin UI]     API --&gt; DB[(Database)]     API --&gt; Storage[Encrypted Storage]</code> </p> Local CI Parity Details <p>Running the <code>make ci-local</code> target (if provided) bundles lint/type/test steps and mirrors CI.</p>"},{"location":"docs/getting-started/#admin-console-access","title":"Admin Console Access","text":"<ul> <li>Default URL: https://localhost:8443/admin/ui</li> <li>Recommended: use a browser profile that isolates cookies and sessions.</li> </ul> Item Default Notes HIPAA Admin Console URL /admin/ui SPA served by Admin API Compliant Login OAuth2 / SSO RBAC enforced Compliant <p>Critical</p> <p>Never use production credentials in local environments. Use test accounts or ephemeral tokens.</p>"},{"location":"docs/getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Read core service docs in /docs/core/</li> <li>Read plugin development guide in /docs/plugins/</li> <li> <p>Explore API Reference /docs/api-reference.md</p> </li> <li> <p> Review Security &amp; Compliance guide</p> </li> <li> Configure retention and audit policies</li> </ul> Advanced <p>For CI-like UI builds, run ++make ui-ci-local++. This target runs UI builds only when Node is present and fails fast on build errors.</p>"},{"location":"docs/security/","title":"Security","text":"<ul> <li> <p>:material-security:{ .lg .middle } Security &amp; Compliance</p> </li> <li> <p>:material-shield-check:{ .lg .middle } HIPAA Controls</p> </li> <li> <p>:material-lock_open:{ .lg .middle } Encryption &amp; Keys</p> </li> </ul> <p>Critical</p> <p>Security controls are mandatory for all deployments. PHI/PII handling requires encryption, audit, and RBAC.</p> <p>Policy Note</p> <p>Use org-approved KMS and secrets storage for production keys. Local dev may use file-backed keys only for testing.</p> <p>Operational Tip</p> <p>Rotate service tokens and keys regularly; automate rotation when possible.</p>"},{"location":"docs/security/#high-level-policies","title":"High-level policies","text":"Domain Requirement Notes Encryption AES-256 at rest, TLS in transit KMS preferred Audit 7-year retention Immutable logs where possible Access Control RBAC, least privilege Scopes for services Monitoring Alerts on anomalies Integrate SIEM <p><code>mermaid graph LR     User --&gt; Auth[Auth Service]     Auth --&gt; AdminAPI     AdminAPI --&gt; Storage     Storage --&gt; Audit[(Audit Logs)]     Audit --&gt; SIEM</code> </p>"},{"location":"docs/security/#key-controls","title":"Key controls","text":"<ul> <li>Encryption at rest and in transit</li> <li>Key management via KMS</li> <li>Immutable audit logs with retention</li> <li>Regular security scans and vulnerability management</li> </ul>"},{"location":"docs/security/#example-enforcing-encryption-on-storage-writes","title":"Example: enforcing encryption on storage writes","text":"PythonNode.jscurl <pre><code># (1) Example: attach KMS key metadata on store requests\npayload = {\"key\":\"patient/1/record.json\",\"kms_key\":\"arn:aws:kms:...\",\"data\":\"...\"}\nrequests.post('https://localhost:8443/api/v1/storage/objects', json=payload)\n</code></pre> <pre><code>// (1) Include kms_key in metadata when uploading\nconst payload = { key: 'patient/1/record.json', kms_key: 'arn:aws:kms:...', data: '...' }\nfetch('https://localhost:8443/api/v1/storage/objects', { method: 'POST', body: JSON.stringify(payload) })\n</code></pre> <pre><code># (1) cURL include kms\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"patient/1/record.json\",\"kms_key\":\"arn:aws:kms:...\",\"data\":\"...\"}' https://localhost:8443/api/v1/storage/objects\n</code></pre> <ol> <li>Attach KMS key metadata to ensure encryption policy compliance</li> </ol> Breach Response <p>Maintain an incident response plan and a chain-of-custody for forensic preservation. Notify stakeholders per legal requirements.</p> <p>Critical</p> <p>If a key is suspected compromised, rotate immediately and initiate the breach response playbook.</p>"},{"location":"docs/troubleshooting/","title":"Troubleshooting","text":"<ul> <li> <p>:material-alert-circle:{ .lg .middle } Troubleshooting</p> </li> <li> <p>:material-search:{ .lg .middle } Diagnostics</p> </li> <li> <p>:material-bug_report:{ .lg .middle } Failure Modes</p> </li> </ul> <p>Start Here</p> <p>Always run local CI parity (<code>make ci-local</code>) before debugging a failing PR.</p> <p>Debugging Tip</p> <p>Use the Admin Console storage browser and messaging DLQ to inspect failed artifacts.</p> <p>Security Warning</p> <p>Do not copy PHI into public issue trackers. Use anonymized reproductions or controlled uploads to secure logs.</p>"},{"location":"docs/troubleshooting/#common-issues-resolutions","title":"Common issues &amp; resolutions","text":"Symptom Likely cause Action CI failures on push Local preflight not run Run pinned toolchain locally Missing UI routes tsc --noEmit catches missing imports Ensure all components are committed mypy errors Optional defaults typed incorrectly Use <code>T | None</code> or Optional[T] <p><code>mermaid flowchart TD     Problem --&gt; Diagnose[Run Preflight &amp; Logs]     Diagnose --&gt; Fix[Apply Fix]     Fix --&gt; Test[Re-run Tests]</code> </p>"},{"location":"docs/troubleshooting/#linttypetest-troubleshooting","title":"Lint/type/test troubleshooting","text":"PythonNode.jscurl <pre><code># (1) Run the exact commands CI runs\nblack --check core/ || (echo \"Run: black core/\" &amp;&amp; exit 1)\nflake8 core/\nmypy --config-file mypy.ini core/\nPYTHONPATH=$PWD pytest -q\n</code></pre> <pre><code>// (1) If Admin UI failing, run in core/admin_ui\n// npm ci &amp;&amp; npm run build\n</code></pre> <pre><code># (1) Check API health\ncurl -k https://localhost:8443/api/v1/health\n</code></pre> <ol> <li>Follow the CI parity steps exactly</li> </ol> Async tests <p>Ensure pytest-asyncio is installed and <code>@pytest.mark.asyncio</code> is used for async tests.</p>"},{"location":"docs/troubleshooting/#when-to-open-an-incident","title":"When to open an incident","text":"<ul> <li>Data loss or possible breach</li> <li>Persistent CI failures blocking merges across many PRs</li> <li>Reproducible data corruption in storage</li> </ul> Severity Action P0 Initiate incident response, notify security P1 Create hotfix branch, run full CI pipeline <p>Recovery Tip</p> <p>Use message replay and audit logs to reconstruct events after a failure.</p>"},{"location":"docs/core/","title":"Index","text":"<ul> <li> <p>:material-shield-check:{ .lg .middle } Core Services</p> <p>Overview of canonical, storage, messaging, gateway</p> </li> <li> <p>:material-extension:{ .lg .middle } Plugin-Ready</p> <p>Core services expose plugin integration points</p> </li> <li> <p>:material-insights:{ .lg .middle } Observability</p> <p>Metrics, logs, and audit streams</p> </li> </ul> <p>Implementation Note</p> <p>Core services are user-facing: they provide normalized data, secure storage, messaging and gateway features to integrators and operators.</p> <p>Pro Tip</p> <p>Start with canonical and storage integration when adding a new plugin\u2014data normalization and retention are foundational.</p> <p>Security Warning</p> <p>All core service APIs enforce RBAC and must be called via the Admin API or authorized plugin connectors.</p>"},{"location":"docs/core/#core-services-map","title":"Core services map","text":"Service Purpose Exposed APIs HIPAA canonical Data normalization &amp; transformation /canonical/* Compliant storage Encrypted PHI/PII storage /storage/* Compliant messaging Event bus &amp; routing /messaging/* Compliant gateway External API proxy /gateway/* Compliant <p><code>mermaid graph TD     Admin[Admin Console] --&gt; API[Admin API]     API --&gt; Canonical[canonical]     API --&gt; Storage[storage]     API --&gt; Messaging[messaging]     API --&gt; Gateway[gateway]     Storage --&gt;|Encrypted| DB[(Encrypted DB)]     Messaging --&gt;|Event Bus| Broker[(Message Broker)]</code></p>"},{"location":"docs/core/#how-to-pick-a-starting-service","title":"How to pick a starting service","text":"<ul> <li>If you need consistent user data across plugins =&gt; canonical</li> <li>If you need long-term PHI/PII storage =&gt; storage</li> <li>If you need cross-plugin events =&gt; messaging</li> <li>If you need to expose external endpoints =&gt; gateway</li> </ul> Service SLAs &amp; Retention <p>Each service has configuration-driven retention and SLA settings. See /docs/configuration.md for per-service options.</p>"},{"location":"docs/core/#quick-integration-example-send-a-canonical-message","title":"Quick integration example (send a canonical message)","text":"PythonNode.jscurl <pre><code># (1) Build a canonical message payload\npayload = {\n    \"from_user\": \"alice\",\n    \"to_user\": \"bob\",\n    \"content_type\": \"text/plain\",\n    \"content\": b\"Hello, Bob!\",\n}\n# (2) Post to Admin API\nimport requests\nr = requests.post('https://localhost:8443/api/v1/messaging/send', json=payload)\n</code></pre> <pre><code>// (1) Node example using fetch\nconst payload = { from_user: 'alice', to_user: 'bob', content_type: 'text/plain', content: Buffer.from('Hello Bob!').toString('base64') }\nfetch('https://localhost:8443/api/v1/messaging/send', { method: 'POST', body: JSON.stringify(payload) })\n</code></pre> <pre><code># (1) cURL example\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"from_user\":\"alice\",\"to_user\":\"bob\",\"content_type\":\"text/plain\",\"content\":\"SGVsbG8sIEJvYg==\"}' https://localhost:8443/api/v1/messaging/send\n</code></pre> <ol> <li>Build canonical payload</li> <li>Use Admin API to submit messages</li> </ol> <p>Compatibility</p> <p>Plugins should accept canonical payloads from the canonical service rather than defining their own ad-hoc formats to maximize interoperability.</p>"},{"location":"docs/core/#see-also","title":"See also","text":"<ul> <li>core/canonical.md</li> <li>core/storage.md</li> <li>core/messaging.md</li> <li>core/gateway.md</li> </ul>"},{"location":"docs/core/canonical/","title":"Canonical","text":"<ul> <li> <p>:material-format-list-bulleted:{ .lg .middle } Canonical Service</p> </li> <li> <p>:material-account-circle:{ .lg .middle } User Canonicals</p> </li> <li> <p>:material-sync:{ .lg .middle } Transformation Pipelines</p> </li> </ul> <p>Normalization Best Practice</p> <p>Always map plugin-specific attributes to the CanonicalUser attributes to maintain cross-plugin compatibility.</p> <p>Implementation Note</p> <p>The canonical service provides Pydantic models for normalized types (eg. CanonicalUser, CanonicalMessage). Plugins should import and reuse these models.</p> <p>Critical</p> <p>Ensure PHI/PII transformations are logged and reversible where required by policy (or flagged with irreversible scrub operations).</p>"},{"location":"docs/core/canonical/#canonical-models","title":"Canonical models","text":"Model Purpose Key fields CanonicalUser Unified user representation id, username, email, roles, traits CanonicalMessage Standard message envelope id, from_user, to_user, content_type, content <p><code>mermaid graph LR     PluginA --&gt;|send| Canonical     PluginB --&gt;|receive| Canonical     Canonical --&gt; Storage     Canonical --&gt; Audit[(Audit Logs)]</code></p>"},{"location":"docs/core/canonical/#canonicaluser-schema-excerpt","title":"CanonicalUser (schema excerpt)","text":"PythonNode.jscurl <pre><code># (1) Example Pydantic model usage\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\n\nclass CanonicalUser(BaseModel):\n    id: str\n    username: str\n    email: str\n    roles: list[str] = Field(default_factory=list)\n    traits: list[str] = Field(default_factory=list)\n    created_at: datetime\n    attributes: dict[str, str] = Field(default_factory=dict)\n</code></pre> <pre><code>// (1) Example of validating a canonical user in Node (pseudo)\nconst user = { id: 'u1', username: 'alice', email: 'alice@example.com', roles: [] }\n// Validate with your schema library (e.g. ajv)\n</code></pre> <pre><code># (1) Create a canonical user via Admin API\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"id\":\"u1\",\"username\":\"alice\",\"email\":\"alice@example.com\"}' https://localhost:8443/api/v1/canonical/users\n</code></pre> <ol> <li>Pydantic-based model for Python</li> </ol>"},{"location":"docs/core/canonical/#transformation-pipeline","title":"Transformation pipeline","text":"<p>The canonical service supports configurable transforms:</p> <ul> <li>Normalizers (case, diacritics)</li> <li>Trait mapping</li> <li>PHI/PII tagging</li> </ul> Component Description Configurable Normalizer Standardize field formats \u2705 Tagger Apply data traits/labels \u2705 Transformer Custom plugin transforms \u2705 <p><code>mermaid flowchart LR     InputData --&gt; Normalizer     Normalizer --&gt; Tagger     Tagger --&gt; Transformer     Transformer --&gt; CanonicalStore[(Canonical Store)]</code> </p> Custom Transformations <p>Use plugin hooks to register custom transformers. Transformers must be idempotent and audit their outputs.</p>"},{"location":"docs/core/canonical/#auditing","title":"Auditing","text":"<p>All canonical operations produce audit events with before/after digests. Audit logs are queryable via Admin API.</p> Audit Field Meaning Retention operation create/update/delete 7 years actor user or plugin 7 years diff before/after 7 years <p>Pro Tip</p> <p>Use the Admin Console's storage browser to validate canonical outputs visually.</p>"},{"location":"docs/core/gateway/","title":"Gateway","text":"<ul> <li> <p>:material-gateway:{ .lg .middle } External Gateway</p> </li> <li> <p>:material-lock_open:{ .lg .middle } Security Validation</p> </li> <li> <p>:material-sensors:{ .lg .middle } Rate Limiting &amp; Monitoring</p> </li> </ul> <p>Design Note</p> <p>The gateway validates and filters external requests, applies transformations, and routes to internal services.</p> <p>Pro Tip</p> <p>Use domain allowlists and request body schema validation to minimize attack surface.</p> <p>Network Security</p> <p>All external traffic must traverse the gateway and be TLS-terminated. Do not expose internal services directly.</p>"},{"location":"docs/core/gateway/#gateway-responsibilities","title":"Gateway responsibilities","text":"Capability Description Default Notes Proxying Forward external requests \u2705 Uses domain allowlist Request validation Schema &amp; security checks \u2705 Rejects invalid payloads Transformations Request/response mapping \u2705 Plugin-configurable Rate limiting Per-API and per-client \u2705 Protects backend <p><code>mermaid graph LR     Client --&gt;|HTTPS| Gateway     Gateway --&gt;|Validate| Auth[Auth Service]     Gateway --&gt;|Proxy| API[Admin API]     Gateway --&gt;|Transform| Backend[Internal Services]</code> </p>"},{"location":"docs/core/gateway/#example-creating-an-external-proxy-route","title":"Example: creating an external proxy route","text":"PythonNode.jscurl <pre><code># (1) Register a domain and route via Admin API\npayload = {\"domain\": \"api.partner.example\", \"target\": \"https://internal-service:8080\"}\nimport requests\nr = requests.post('https://localhost:8443/api/v1/gateway/routes', json=payload)\n</code></pre> <pre><code>// (1) Node register route (pseudo)\nconst route = { domain: 'api.partner.example', target: 'https://internal-service:8080' }\nfetch('https://localhost:8443/api/v1/gateway/routes', { method: 'POST', body: JSON.stringify(route) })\n</code></pre> <pre><code># (1) cURL register route\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"domain\":\"api.partner.example\",\"target\":\"https://internal-service:8080\"}' https://localhost:8443/api/v1/gateway/routes\n</code></pre> <ol> <li>Routes are validated and stored</li> </ol> Monitoring <p>The gateway emits metrics for request counts, latency, and rate-limit events to the platform metrics endpoint.</p>"},{"location":"docs/core/gateway/#security-rate-limiting","title":"Security &amp; rate limiting","text":"Limit Type Default Notes Per-client QPS 10 Configurable Burst 50 Configurable <p>DoS Protection</p> <p>Configure WAF rules at the gateway and ensure alerts on sustained high error rates.</p>"},{"location":"docs/core/messaging/","title":"Messaging","text":"<ul> <li> <p>:material-forum:{ .lg .middle } Messaging (Event Bus)</p> </li> <li> <p>:material-filter_list:{ .lg .middle } Routing &amp; Filters</p> </li> <li> <p>:material-history:{ .lg .middle } Message Audit Trails</p> </li> </ul> <p>Design Tip</p> <p>Use canonical messages to encapsulate payloads and avoid leaking schema differences between plugins.</p> <p>Operational Note</p> <p>The messaging layer enforces PHI/PII protection\u2014messages flagged with PHI are handled with stricter routing and audit requirements.</p> <p>Throughput Warning</p> <p>For high-volume plugins, configure partitioning and backpressure to avoid message loss.</p>"},{"location":"docs/core/messaging/#messaging-features","title":"Messaging features","text":"Feature Description Default HIPAA Event bus Pub/Sub or broker-backed bus Broker Compliant Routing Topic and attribute routing \u2705 Compliant Filters Policy-driven filtering \u2705 Compliant Replay Replay events for recovery Configurable Compliant <p><code>mermaid graph LR     PluginA --&gt;|publish| Messaging     Messaging --&gt;|route| PluginB     Messaging --&gt; Audit[(Audit Logs)]     Messaging --&gt; Storage</code> </p>"},{"location":"docs/core/messaging/#publishsubscribe-examples","title":"Publish/subscribe examples","text":"PythonNode.jscurl <pre><code># (1) Publish a canonical message\nimport requests\npayload = {\"from_user\":\"alice\",\"to_user\":\"bob\",\"content\":\"SGVsbG8=\",\"content_type\":\"text/plain\"}\nrequests.post('https://localhost:8443/api/v1/messaging/publish', json=payload)\n</code></pre> <pre><code>// (1) Node publish example\nconst payload = { from_user: 'alice', to_user: 'bob', content: Buffer.from('Hi').toString('base64') }\nfetch('https://localhost:8443/api/v1/messaging/publish', { method: 'POST', body: JSON.stringify(payload) })\n</code></pre> <pre><code># (1) cURL publish\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"from_user\":\"alice\",\"to_user\":\"bob\",\"content\":\"SGVsbG8=\",\"content_type\":\"text/plain\"}' https://localhost:8443/api/v1/messaging/publish\n</code></pre> <ol> <li>Publish via Admin API</li> </ol> Filtering &amp; Policy <p>Message filters operate using message traits. Tag PHI messages with the appropriate data traits to trigger stricter routing.</p>"},{"location":"docs/core/messaging/#replay-dead-letter-queues","title":"Replay &amp; Dead Letter Queues","text":"<ul> <li>Messages that fail processing are sent to DLQs for manual inspection</li> <li>Replay is supported for investigation and recovery</li> </ul> Queue Purpose Retention DLQ Failed messages 30 days Replay Reprocessable events Configurable <p>Operational Tip</p> <p>Subscribe an admin-only consumer to DLQs to expedite failure triage.</p>"},{"location":"docs/core/overview/","title":"Overview","text":"<ul> <li> <p>:material-shield-check:{ .lg .middle } Core Overview</p> </li> <li> <p>:material-security:{ .lg .middle } Compliance-Centric</p> </li> <li> <p>:material-compare:{ .lg .middle } Interoperability</p> </li> </ul> <p>Start Here</p> <p>Read the canonical and storage docs before implementing plugins that handle user data.</p> <p>Design Note</p> <p>Core services prioritize auditability and configurable retention aligned with HIPAA constraints.</p> <p>Operational Warning</p> <p>Do not bypass audit logs. All transformation and storage operations are logged and retained per configured policies.</p>"},{"location":"docs/core/overview/#architecture-summary","title":"Architecture summary","text":"Layer Responsibility Examples HIPAA Presentation Admin Console, APIs /admin/ui, /api Compliant Core Logic canonical, storage, messaging, gateway Plugins call these Compliant Data Encrypted DBs, Brokers Postgres (encrypted), Kafka Compliant <p><code>mermaid sequenceDiagram     participant User     participant AdminAPI     participant Canonical     participant Storage     User-&gt;&gt;AdminAPI: Create user     AdminAPI-&gt;&gt;Canonical: Normalize user     Canonical--&gt;&gt;Storage: Store canonical user     Storage--&gt;&gt;AdminAPI: Confirmation</code> </p>"},{"location":"docs/core/overview/#observability-audit","title":"Observability &amp; audit","text":"<ul> <li>Centralized audit logs with 7-year retention by default (configurable)</li> <li>Metrics exposed via /metrics for Prometheus</li> </ul> Feature Endpoint Default Retention Audit Logs /admin/audit 7 years Metrics /metrics 90 days"},{"location":"docs/core/overview/#common-integration-workflow","title":"Common integration workflow","text":"<ul> <li>Register plugin in Admin Console</li> <li>Request RBAC roles &amp; scopes</li> <li>Send test data through canonical service</li> <li> <p>Validate stored records via storage browser in Admin Console</p> </li> <li> <p> Register plugin</p> </li> <li> Request roles</li> <li> Test normalization pipeline</li> </ul> Advanced Tuning <p>Use configuration options in /docs/configuration.md to tune retention, encryption keys, and messaging partitions.</p>"},{"location":"docs/core/storage/","title":"Storage","text":"<ul> <li> <p>:material-database:{ .lg .middle } Encrypted Storage</p> </li> <li> <p>:material-lock:{ .lg .middle } HIPAA Compliant</p> </li> <li> <p>:material-label:{ .lg .middle } Classification &amp; Tagging</p> </li> </ul> <p>Encryption Best Practice</p> <p>Use KMS-backed encryption keys and rotate keys periodically following org policy.</p> <p>Retention Note</p> <p>Default retention for audit and PHI is 7 years; override via configuration per dataset.</p> <p>Critical</p> <p>Deleting data before retention policies expire may violate compliance. Ensure deletion flows respect retention windows and legal holds.</p>"},{"location":"docs/core/storage/#storage-capabilities","title":"Storage capabilities","text":"Feature Description Default HIPAA Encryption at rest AES-256 or KMS-backed \u2705 Active Compliant Access controls RBAC + plugin scopes \u2705 Active Compliant Retention policies Configurable policies per dataset 7 years default Compliant Audit logs All accesses recorded \u2705 Active Compliant <p><code>mermaid graph TD     App[Admin API / Plugins] --&gt;|Write| Storage[Encrypted Storage]     Storage --&gt; DB[(Encrypted DB)]     Storage --&gt; Audit[(Audit Logs)]</code> </p>"},{"location":"docs/core/storage/#configuration-options-storage","title":"Configuration options (storage)","text":"Option Type Default Description encryption.kms_key string \"\" KMS key ARN or identifier retention.days int 2555 Retention in days (7 years) classification.auto_tag bool true Auto-tag data with PHI/PII traits audit.retention int 2555 Audit retention in days"},{"location":"docs/core/storage/#example-storing-an-object","title":"Example: storing an object","text":"PythonNode.jscurl <pre><code># (1) Upload an object to encrypted storage via Admin API\nimport requests\nobj = {\"key\":\"patient/123/record.json\",\"data\":\"{\\\"name\\\":\\\"Alice\\\"}\"}\nr = requests.post('https://localhost:8443/api/v1/storage/objects', json=obj)\n</code></pre> <pre><code>// (1) Upload object using fetch (pseudo)\nconst obj = { key: 'patient/123/record.json', data: JSON.stringify({ name: 'Alice' }) }\nfetch('https://localhost:8443/api/v1/storage/objects', { method: 'POST', body: JSON.stringify(obj) })\n</code></pre> <pre><code># (1) cURL upload\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"patient/123/record.json\",\"data\":\"{\\\"name\\\":\\\"Alice\\\"}\"}' https://localhost:8443/api/v1/storage/objects\n</code></pre> <ol> <li>Use Admin API to interact with storage</li> <li>Objects are classified and encrypted automatically</li> </ol> Retention &amp; Legal Holds <p>Use the Admin Console to place legal holds which prevent deletion even if retention expires.</p>"},{"location":"docs/core/storage/#audit-access","title":"Audit &amp; Access","text":"<ul> <li>Access attempts require RBAC checks</li> <li>Failed access attempts are recorded and alerted on</li> </ul> Access Type Triggers Alert Notes Unauthorized read \u2705 Immediate alert Unauthorized write \u2705 Immediate alert <p>Access Controls</p> <p>Ensure plugin tokens are scoped to minimal privileges necessary for their function.</p>"},{"location":"docs/plugins/development/","title":"Development","text":"<ul> <li> <p>:material-widgets:{ .lg .middle } Plugin Development</p> </li> <li> <p>:material-developer_board:{ .lg .middle } Developer Tools</p> </li> <li> <p>:material-storefront:{ .lg .middle } Marketplace Integration</p> </li> </ul> <p>Developer Tip</p> <p>Build plugins against the canonical models to gain immediate compatibility with other services and UI components.</p> <p>Accessibility Mandate</p> <p>All plugin capabilities must be operable from the Admin Console\u2014no CLI-only features.</p> <p>Security Warning</p> <p>Plugins handling PHI must be scoped and audited. Minimally privilege plugin tokens.</p>"},{"location":"docs/plugins/development/#plugin-lifecycle","title":"Plugin lifecycle","text":"Stage What to do UI Steps Register Add plugin metadata Admin Console -&gt; Plugins -&gt; Add Configure Provide credentials &amp; config Admin Console -&gt; Plugin Setup Enable Toggle plugin on Admin Console -&gt; Plugins <p><code>mermaid graph LR     Dev[Developer] --&gt; Register[Register Plugin]     Register --&gt; Configure[Configure Plugin]     Configure --&gt; Enable[Enable &amp; Test]     Enable --&gt; Monitor[Monitor &amp; Audit]</code> </p>"},{"location":"docs/plugins/development/#development-checklist","title":"Development checklist","text":"<ul> <li> Use canonical models for data</li> <li> Expose plugin settings in Admin Console</li> <li> Provide health checks and smoke tests</li> <li> Add storage/browser integration if persisting PHI</li> </ul>"},{"location":"docs/plugins/development/#minimal-plugin-manifest-example","title":"Minimal plugin manifest (example)","text":"PythonNode.jscurl <pre><code># (1) Example plugin manifest\nmanifest = {\n    \"id\": \"com.example.plugin\",\n    \"name\": \"Example Plugin\",\n    \"capabilities\": [\"send_messages\",\"store_records\"],\n}\n</code></pre> <pre><code>// (1) Example manifest in JS\nconst manifest = { id: 'com.example.plugin', name: 'Example Plugin', capabilities: ['send_messages', 'store_records'] }\n</code></pre> <pre><code># (1) Register manifest via Admin API\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"id\":\"com.example.plugin\",\"name\":\"Example Plugin\",\"capabilities\":[\"send_messages\"]}' https://localhost:8443/api/v1/plugins/register\n</code></pre> <ol> <li>Include id, name, and capabilities</li> </ol> Testing <p>Provide unit tests and pytest-asyncio tests for async plugin components. Use in-memory SQLite for DB tests.</p>"},{"location":"docs/plugins/development/#ui-integration-points","title":"UI Integration points","text":"<ul> <li>Provide React components for Settings and Health in the Admin Console</li> <li>Register routes under /admin/ui/plugins/{plugin_id}</li> </ul> Component Path Notes Settings /admin/ui/plugins/{id}/settings Exposed via plugin manifest Health /admin/ui/plugins/{id}/health Show smoke-test results <p>Pro Tip</p> <p>Ship a Provider Setup Wizard component to minimize configuration errors for operators.</p>"},{"location":"pilots/llm-pilot/","title":"Enterprise Pilot Guide: LLM + RAG","text":"<p>This hands-on guide walks a pilot team through plugging in your own LLM and (optionally) your own RAG database backend. It focuses on functionality and time-to-first-demo.</p>"},{"location":"pilots/llm-pilot/#1-start-the-stack","title":"1) Start the stack","text":"<pre><code>docker compose up -d postgres redis vivified-core admin-ui-dev\n</code></pre> <ul> <li>Core API: http://localhost:8000</li> <li>Admin UI (dev): http://localhost:5173</li> </ul>"},{"location":"pilots/llm-pilot/#2-dev-login-pilot","title":"2) Dev login (pilot)","text":"<ul> <li>Admin UI \u2192 click Dev Login (DEV_MODE=true). This issues an admin token locally; do not use for production.</li> </ul>"},{"location":"pilots/llm-pilot/#3-pick-your-provider","title":"3) Pick your provider","text":"<ul> <li>Admin \u2192 Tools \u2192 AI Studio \u2192 LLM Configuration</li> <li>Provider: openai | claude | local</li> <li>Model: dropdown auto-loads from provider (or type manually)</li> <li>Base URL: defaults are filled; adjust for your setup</li> <li>Embeddings Model: defaults to text-embedding-3-small</li> <li>Save</li> </ul> <p>Tips: - OpenAI: paste API key and use <code>gpt-4o-mini</code> (fast/cheap) for demos. - Claude: paste x-api-key; e.g., <code>claude-3.5-sonnet-20240620</code>. - Local: choose <code>local</code>, set Connectors allowlist, and pick <code>llama3.1:8b</code> (Ollama). No PHI/PII recommended in alpha.</p>"},{"location":"pilots/llm-pilot/#4-allowlists-egress","title":"4) Allowlists (egress)","text":"<ul> <li>Admin \u2192 Tools \u2192 AI Studio \u2192 Connectors \u2192 \u201cApply Default AI Allowlist\u201d</li> <li>Verifies gateway allowlist for api.openai.com / api.anthropic.com / local base.</li> </ul>"},{"location":"pilots/llm-pilot/#5-train-rag","title":"5) Train RAG","text":"<ul> <li>Admin \u2192 Tools \u2192 AI Studio \u2192 \u201cTrain Everything (.)\u201d</li> <li>Respects <code>.ragignore</code> and <code>.gitignore</code>.</li> <li>Redis-backed RAG persists; vectors stored per chunk.</li> </ul> <p>Optional RAG tuning: - Ingestion Rules \u2192 RAG Settings \u2192 adjust Chunk Size and Overlap. - Backend = Plugin to delegate storage/search to your own DB plugin (see RAG DB Plugin guide).</p>"},{"location":"pilots/llm-pilot/#6-smoke-test","title":"6) Smoke test","text":"<pre><code>export API_KEY=bootstrap_admin_only\nexport AI_API_URL=http://localhost:8000\nexport OPENAI_API_KEY=sk-...\nmake smoke-ai\n</code></pre> <ul> <li>Checks <code>/admin/ai/status</code>, trains (optional), and queries RAG.</li> </ul>"},{"location":"pilots/llm-pilot/#7-your-plugins","title":"7) Your plugins","text":""},{"location":"pilots/llm-pilot/#llm-oss-plugin","title":"LLM OSS plugin","text":"<ul> <li>Build a plugin with <code>/chat</code> and <code>/embeddings</code> and register it via Admin \u2192 Plugins \u2192 Register.</li> <li>Set Provider=local in AI Studio; models load from your server.</li> <li>See: Plugins \u2192 LLM OSS (Local)</li> </ul>"},{"location":"pilots/llm-pilot/#rag-db-plugin","title":"RAG DB plugin","text":"<ul> <li>Implement <code>rag_index</code> and <code>rag_query</code> (+ manifest endpoints) and register.</li> <li>Operator allowlist: Admin \u2192 Plugin Dev Guide \u2192 Generate Operator Allowlist (caller <code>ai-core</code> \u2192 your plugin: <code>rag_index</code>, <code>rag_query</code>).</li> <li>In AI Studio \u2192 RAG Settings, set Backend=Plugin and your Plugin ID.</li> <li>See: Plugins \u2192 RAG DB Plugin</li> </ul>"},{"location":"pilots/llm-pilot/#8-demo-workflow","title":"8) Demo workflow","text":"<ul> <li>Train \u2192 Query RAG (shows top matches, TBAC filtered)</li> <li>Agent Run: ask \u201cSummarize Vivified core and how plugins integrate\u201d</li> <li>Show TBAC chips (\u201cYour Traits\u201d, \u201cRequired Traits\u201d, \u201cBlocked\u201d) for transparency</li> <li>Show Connectors and Allowlist view to confirm egress controls</li> </ul>"},{"location":"pilots/llm-pilot/#9-whats-next","title":"9) What\u2019s next","text":"<ul> <li>Add metrics panels in Admin \u2192 Monitoring</li> <li>Add your own tool(s) to the agent (HTTP fetch via proxy, storage ops)</li> <li>Optional: switch to Redis Stack (6380) or your DB plugin for ANN vector search</li> </ul>"},{"location":"plugins/development/","title":"Development Guide","text":"<ul> <li> <p>:material-widgets:{ .lg .middle } Plugin Development</p> <p>How to build, register, and test plugins for Vivified</p> </li> <li> <p>:material-extension:{ .lg .middle } Plugin API</p> <p>Plugin lifecycle, registration, and capabilities</p> </li> <li> <p>:material-publish:{ .lg .middle } Marketplace Ready</p> <p>Packaging and publishing guidelines for the Admin Console marketplace</p> </li> </ul> <p>!!! tip 'Start with canonical models'     Use canonical types when designing plugin inputs/outputs to ensure compatibility with other plugins and core services.</p> <p>!!! note 'Admin Console integration'     Every plugin must expose administrative UI components when applicable; no CLI-only features.</p> <p>!!! warning 'Security review required'     Plugins that access PHI require additional security review and must declare required roles and capabilities.</p>"},{"location":"plugins/development/#plugin-anatomy","title":"Plugin anatomy","text":"<ul> <li>manifest.yaml \u2014 metadata and capabilities</li> <li>server/ \u2014 plugin runtime (Python/Node)</li> <li>ui/ \u2014 optional Admin UI components</li> <li>tests/ \u2014 unit and integration tests</li> </ul>"},{"location":"plugins/development/#manifest-example-conceptual","title":"Manifest example (conceptual)","text":"Field Purpose Example Required name Plugin name my-plugin yes version Semver 1.0.0 yes capabilities Roles and hooks canonical-adapter recommended ui Admin UI entry points /admin/plugins/my-plugin recommended"},{"location":"plugins/development/#lifecycle","title":"Lifecycle","text":"<p><code>mermaid sequenceDiagram   participant Admin   participant Plugin   participant Core   Admin-&gt;&gt;Core: register(plugin manifest)   Core-&gt;&gt;Plugin: initialize   Plugin-&gt;&gt;Core: register handlers   Core-&gt;&gt;Admin: plugin registered</code></p>"},{"location":"plugins/development/#example-plugin-registration-via-api","title":"Example: plugin registration via API","text":"PythonNode.jscurl <pre><code># (1)\nimport requests\nresp = requests.post('https://admin.example/api/plugins', json={'name': 'my-plugin', 'version':'1.0.0'})\nprint(resp.json())\n</code></pre> <pre><code>// (1)\nconst fetch = require('node-fetch')\nawait fetch('https://admin.example/api/plugins', { method: 'POST', body: JSON.stringify({ name: 'my-plugin', version: '1.0.0' }) })\n</code></pre> <pre><code># (1)\ncurl -X POST https://admin.example/api/plugins -H 'Content-Type: application/json' -d '{\"name\":\"my-plugin\",\"version\":\"1.0.0\"}'\n</code></pre> <ol> <li>Register a plugin manifest with the Admin API; plugin will be initialized and provided with secrets</li> </ol>"},{"location":"plugins/development/#development-checklist","title":"Development checklist","text":"<ul> <li> Implement canonical adapters if exchanging user/message data</li> <li> Provide Admin UI components for configuration</li> <li> Add unit and async tests (++pytest++ for Python)</li> <li> Submit security review for PHI access</li> </ul> <p>??? note 'Testing'     Use in-memory SQLite for tests and avoid network/DB calls at import time. Mark async tests with ++@pytest.mark.asyncio++.</p>"},{"location":"plugins/development/#packaging-marketplace","title":"Packaging &amp; Marketplace","text":"Item Description Required manifest.yaml Plugin metadata yes signed package Optional for marketplace recommended UI bundle Admin UI assets (if present) recommended <p>!!! danger 'Unsigned plugins'     Do not install unsigned plugins in production without an explicit security review.</p> <ol> <li> <p>Plugins must adhere to Admin Console accessibility and provide keyboard-navigable UI components.\u00a0\u21a9</p> </li> </ol>"},{"location":"plugins/examples/","title":"Plugin Examples","text":"<p>Walkthroughs for common plugin patterns: notifier, storage, LLM connectors, and RAG DB backends.</p>"},{"location":"plugins/llm-oss/","title":"LLM OSS Plugin (Local/Ollama/GPT\u2011OSS)","text":"<p>This guide shows how to build and wire a custom LLM plugin that runs on\u2011prem (e.g., Ollama or a GPT\u2011OSS server). It covers manifest design, allowlists, operator endpoints, and Admin Console setup.</p>"},{"location":"plugins/llm-oss/#goals","title":"Goals","text":"<ul> <li>Provider isolation: your plugin talks to your LLM, Core mediates everything.</li> <li>TBAC and audit: all calls logged and policy\u2011enforced.</li> <li>Easy UI: pick <code>local</code> provider, select models via <code>/admin/ai/models</code> when reachable.</li> </ul>"},{"location":"plugins/llm-oss/#manifest","title":"Manifest","text":"<pre><code>{\n  \"id\": \"llm-oss\",\n  \"name\": \"LLM OSS (Local)\",\n  \"version\": \"0.1.0\",\n  \"contracts\": [\"llm\", \"embeddings\"],\n  \"traits\": [\"plugin_manager\"],\n  \"allowed_domains\": [],\n  \"endpoints\": {\n    \"chat\": \"/chat\",\n    \"embeddings\": \"/embeddings\"\n  },\n  \"security\": {\"scopes\": [\"llm:chat\", \"llm:embeddings\"]},\n  \"compliance\": {\"hipaa_controls\": [\"164.312(a)\"]}\n}\n</code></pre> <ul> <li><code>endpoints.chat</code> and <code>endpoints.embeddings</code> are relative paths exposed by your container on port 8080 by default (configurable via <code>host</code>/<code>port</code> in manifest).</li> </ul>"},{"location":"plugins/llm-oss/#endpoints","title":"Endpoints","text":"<ul> <li>POST <code>/chat</code></li> <li>Body: <code>{ \"messages\": [...], \"tools?\": [...], \"model\": \"name\", \"max_tokens?\": 1024 }</code></li> <li>Return: <code>{ \"text\": \"...\", \"tool_calls?\": [{\"name\":\"...\",\"arguments\":{...}}] }</code></li> <li>POST <code>/embeddings</code></li> <li>Body: <code>{ \"input\": \"text or list\", \"model\": \"name\" }</code></li> <li>Return: <code>{ \"data\": [{ \"embedding\": [float, ...] }] }</code></li> </ul> <p>Your plugin translates these to your backend (Ollama, GPT\u2011OSS) and returns normalized results.</p>"},{"location":"plugins/llm-oss/#registration-allowlist","title":"Registration + Allowlist","text":"<ol> <li>Admin Console \u2192 Plugins \u2192 Register \u2192 paste manifest \u2192 Register.</li> <li>Admin Console \u2192 Plugins \u2192 Policies \u2192 Apply Suggested Allowlist (if your plugin calls external hosts; most local setups won\u2019t).</li> <li>Admin Console \u2192 Tools \u2192 AI Studio \u2192 Provider = <code>local</code>.</li> <li>Models dropdown auto\u2011loads from <code>http://localhost:11434/api/tags</code> (if reachable) via <code>/admin/ai/models</code>.</li> </ol>"},{"location":"plugins/llm-oss/#operator-calls-optional","title":"Operator Calls (optional)","text":"<p>If other plugins (or Core) must call your plugin synchronously, implement additional <code>endpoints</code> and allow them via <code>PUT /admin/operator/allowlist</code> (GUI: Plugin Dev Guide \u2192 Generate Operator Allowlist). Core exposes:</p> <ul> <li><code>POST /gateway/{target_plugin}/{operation}</code> \u2192 forwards JSON payload to the plugin endpoint.</li> <li>Policy and operator allowlist are enforced; every call audited.</li> </ul>"},{"location":"plugins/llm-oss/#security","title":"Security","text":"<ul> <li>All secrets live in ConfigService. Never hardcode keys.</li> <li>Gateway deny\u2011lists unsafe hosts and IP literals; only allowed domains pass.</li> <li>Logs redact PHI/PII.</li> </ul>"},{"location":"plugins/llm-oss/#testing","title":"Testing","text":"<ul> <li>Use <code>make smoke-ai</code> to validate RAG and embeddings end\u2011to\u2011end.</li> <li>Use Admin Console ChatBot and AI Studio to verify chat responses and tool calls.</li> </ul> <pre><code># Example local run\ndocker compose up -d vivified-core redis postgres admin-ui-dev\n</code></pre>"},{"location":"plugins/overview/","title":"Plugins Overview","text":"<p>The Vivified platform is built on a powerful plugin architecture that enables modular, extensible functionality while maintaining security and HIPAA compliance. Plugins are the primary way to extend and customize the platform.</p> <ul> <li> <p>:material-puzzle:{ .lg .middle } Modular Architecture</p> <p>Isolated microservices communicate through well-defined APIs</p> </li> <li> <p>:material-security:{ .lg .middle } Secure by Default</p> <p>Sandboxed execution with policy-based access control</p> </li> <li> <p>:material-code-tags:{ .lg .middle } Polyglot Support</p> <p>Build plugins in Python, Node.js, Go, or any language</p> </li> </ul>"},{"location":"plugins/overview/#what-are-plugins","title":"What are Plugins?","text":"<p>Plugins are containerized microservices that add features to Vivified without modifying core code. Each plugin:</p> <ul> <li>Runs in isolation - Containerized with resource limits</li> <li>Communicates through APIs - REST or gRPC interfaces  </li> <li>Follows security policies - Enforced by the core platform</li> <li>Integrates with Admin UI - Provides web-based management</li> </ul>"},{"location":"plugins/overview/#plugin-categories","title":"Plugin Categories","text":"Category Purpose Examples Storage Data persistence and retrieval S3 adapter, PostgreSQL connector Communication Messaging and notifications Email sender, SMS gateway, Slack Identity User management and authentication LDAP, OAuth2, SAML Processing Data transformation and analysis OCR engine, ML models, ETL Integration External system connectors EHR systems, billing platforms"},{"location":"plugins/overview/#three-lane-communication-model","title":"Three-Lane Communication Model","text":"<p>All plugin interactions follow one of three supervised communication patterns:</p> <p><code>mermaid graph LR     Plugin1[Plugin A] --&gt;|Canonical Events| EventBus[Event Bus]     EventBus --&gt; Plugin2[Plugin B]     Plugin1 --&gt;|Operator API| Gateway[Core Gateway]     Gateway --&gt; Plugin2     Plugin1 --&gt;|Proxy Lane| Proxy[Core Proxy]     Proxy --&gt;|Filtered| External[External API]</code></p>"},{"location":"plugins/overview/#1-canonical-lane","title":"1. Canonical Lane","text":"<ul> <li>Purpose: Asynchronous event-driven communication</li> <li>Format: Normalized canonical data models</li> <li>Example: User created, document processed, payment received</li> </ul>"},{"location":"plugins/overview/#2-operator-lane","title":"2. Operator Lane","text":"<ul> <li>Purpose: Synchronous API calls between plugins</li> <li>Format: REST/gRPC with authentication</li> <li>Example: Fetch user details, validate configuration</li> </ul>"},{"location":"plugins/overview/#3-proxy-lane","title":"3. Proxy Lane","text":"<ul> <li>Purpose: Controlled external API access</li> <li>Format: HTTP/HTTPS with domain allowlisting</li> <li>Example: Call third-party services, webhooks</li> </ul>"},{"location":"plugins/overview/#plugin-lifecycle","title":"Plugin Lifecycle","text":"<p><code>mermaid stateDiagram-v2     [*] --&gt; Unregistered     Unregistered --&gt; Registered: Register with manifest     Registered --&gt; Active: Enable plugin     Active --&gt; Disabled: Disable plugin     Disabled --&gt; Active: Re-enable     Active --&gt; Unhealthy: Health check fails     Unhealthy --&gt; Active: Health restored     Disabled --&gt; Unregistered: Unregister</code></p>"},{"location":"plugins/overview/#getting-started","title":"Getting Started","text":""},{"location":"plugins/overview/#quick-start","title":"Quick Start","text":"<ol> <li>Browse Available Plugins</li> <li>Visit Admin Console \u2192 Plugins \u2192 Marketplace</li> <li> <p>Filter by category, traits, or capabilities</p> </li> <li> <p>Install a Plugin</p> </li> <li>Click \"Install\" on desired plugin</li> <li>Configure required settings</li> <li> <p>Enable and verify health status</p> </li> <li> <p>Build Your Own</p> </li> <li>See Development Guide for detailed instructions</li> <li>Use SDK for your preferred language: Python, Node.js, Go</li> <li>Follow the Plugin Examples</li> </ol>"},{"location":"plugins/overview/#plugin-manifest","title":"Plugin Manifest","text":"<p>Every plugin requires a manifest declaring its capabilities and requirements:</p> <pre><code>{\n  \"id\": \"my-plugin\",\n  \"name\": \"My Plugin\", \n  \"version\": \"1.0.0\",\n  \"contracts\": [\"StoragePlugin\"],\n  \"traits\": [\"handles_pii\", \"audit_required\"],\n  \"security\": {\n    \"authentication_required\": true,\n    \"data_classification\": [\"pii\"]\n  },\n  \"allowed_domains\": [\"api.example.com\"]\n}\n</code></pre>"},{"location":"plugins/overview/#security-compliance","title":"Security &amp; Compliance","text":""},{"location":"plugins/overview/#security-requirements","title":"Security Requirements","text":"<p>Security Mandatory</p> <p>All plugins MUST implement authentication and declare data classification</p> <ul> <li>Authentication: Required for all plugin endpoints</li> <li>Authorization: Role-based access control via traits</li> <li>Audit Logging: Automatic for sensitive operations</li> <li>Data Classification: Must declare PII/PHI handling</li> </ul>"},{"location":"plugins/overview/#hipaa-compliance","title":"HIPAA Compliance","text":"<p>For healthcare deployments, plugins handling PHI must:</p> <ul> <li>Declare <code>handles_phi</code> trait</li> <li>Implement required HIPAA controls</li> <li>Support 7-year audit retention</li> <li>Encrypt data at rest and in transit</li> </ul>"},{"location":"plugins/overview/#plugin-management","title":"Plugin Management","text":""},{"location":"plugins/overview/#admin-console-features","title":"Admin Console Features","text":"Feature Description Access Required Browse Marketplace View available plugins <code>admin</code> Install/Uninstall Manage plugin lifecycle <code>plugin_manager</code> Configure Edit plugin settings <code>config_manager</code> Monitor Health View status and metrics <code>admin</code> View Audit Logs Track plugin actions <code>audit_viewer</code>"},{"location":"plugins/overview/#cli-management","title":"CLI Management","text":"<pre><code># List installed plugins\nvivified plugins list\n\n# Install from marketplace\nvivified plugins install &lt;plugin-id&gt;\n\n# Configure plugin\nvivified plugins config &lt;plugin-id&gt; --set key=value\n\n# Check plugin health\nvivified plugins health &lt;plugin-id&gt;\n</code></pre>"},{"location":"plugins/overview/#available-plugins","title":"Available Plugins","text":""},{"location":"plugins/overview/#core-plugins","title":"Core Plugins","text":"<ul> <li>LLM OSS Plugin - Local language model integration</li> <li>RAG Database Plugin - Vector database for retrieval-augmented generation</li> </ul>"},{"location":"plugins/overview/#community-plugins","title":"Community Plugins","text":"<p>Browse the Plugin Marketplace for community-contributed plugins.</p>"},{"location":"plugins/overview/#best-practices","title":"Best Practices","text":"<p>Plugin Development Tips</p> <ol> <li>Start with the SDK for your language</li> <li>Follow the principle of least privilege</li> <li>Implement comprehensive health checks</li> <li>Provide Admin UI components when applicable</li> <li>Document all configuration options</li> </ol>"},{"location":"plugins/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Developers: Read the Plugin Development Guide</li> <li>Administrators: Explore the Plugin System architecture</li> <li>Examples: Review Plugin Examples for common patterns</li> </ul>"},{"location":"plugins/plugin-system/","title":"Plugin System Architecture","text":"<p>The Vivified platform is built on a sophisticated plugin architecture that enables secure, modular extensibility while maintaining HIPAA compliance and enterprise-grade security.</p> <ul> <li> <p>:material-puzzle:{ .lg .middle } Modular Design</p> <p>Isolated microservices with well-defined contracts</p> </li> <li> <p>:material-security:{ .lg .middle } Security First</p> <p>Sandboxed execution with comprehensive validation</p> </li> <li> <p>:material-lan-connect:{ .lg .middle } Three-Lane Communication</p> <p>Canonical events, operator APIs, and controlled proxy access</p> </li> </ul>"},{"location":"plugins/plugin-system/#what-are-plugins","title":"What Are Plugins?","text":"<p>Vivified plugins are containerized microservices that extend platform functionality without modifying core code. Each plugin operates in complete isolation, communicating through well-defined interfaces.</p>"},{"location":"plugins/plugin-system/#key-benefits","title":"Key Benefits","text":"<ul> <li> <p>:material-plus-circle:{ .lg .middle } Extensibility</p> <p>Add features without changing core code</p> </li> <li> <p>:material-shield-lock:{ .lg .middle } Isolation &amp; Security</p> <p>Sandboxed execution prevents cascading failures</p> </li> <li> <p>:material-code-tags:{ .lg .middle } Polyglot Development</p> <p>Build in Python, Node.js, Go, or any language</p> </li> <li> <p>:material-view-module:{ .lg .middle } Modularity</p> <p>Deploy only the plugins you need</p> </li> </ul> <p>Plugin-First Architecture</p> <p>Even core capabilities like identity management and notifications are implemented as plugins, making the platform extremely flexible.</p>"},{"location":"plugins/plugin-system/#communication-architecture","title":"Communication Architecture","text":"<p>All plugin communication flows through the Vivified core, ensuring consistent security policy enforcement.</p>"},{"location":"plugins/plugin-system/#three-lane-model","title":"Three-Lane Model","text":"<p>```mermaid graph TB     subgraph \"Plugin A\"         PA[Plugin A]     end</p> <pre><code>subgraph \"Core Platform\"\n    EventBus[Event Bus&lt;br/&gt;Canonical Lane]\n    Gateway[API Gateway&lt;br/&gt;Operator Lane]\n    Proxy[Proxy Service&lt;br/&gt;Proxy Lane]\nend\n\nsubgraph \"Plugin B\"\n    PB[Plugin B]\nend\n\nsubgraph \"External\"\n    EXT[External APIs]\nend\n\nPA --&gt;|Events| EventBus\nEventBus --&gt; PB\nPA --&gt;|API Calls| Gateway\nGateway --&gt; PB\nPA --&gt;|Filtered Access| Proxy\nProxy --&gt; EXT\n</code></pre> <p>```</p>"},{"location":"plugins/plugin-system/#1-canonical-event-lane","title":"1. Canonical Event Lane","text":"<p>Purpose: Asynchronous, decoupled communication via normalized events</p> Event PublishingEvent Subscription <pre><code>{\n  \"event_type\": \"user.created\",\n  \"data\": {\n    \"user_id\": \"123\",\n    \"email\": \"user@example.com\",\n    \"created_at\": \"2025-01-01T00:00:00Z\"\n  },\n  \"metadata\": {\n    \"source\": \"identity-service\",\n    \"classification\": \"pii\"\n  }\n}\n</code></pre> <pre><code>@plugin.on_event(\"user.created\")\nasync def handle_user_created(event):\n    # Set up user workspace\n    await create_user_workspace(event.data.user_id)\n</code></pre> <p>Use Cases</p> <ul> <li>HR plugin emits <code>UserCreated</code> \u2192 Accounting plugin sets up payroll</li> <li>Document plugin emits <code>DocumentProcessed</code> \u2192 Notification plugin sends alerts</li> <li>Payment plugin emits <code>PaymentReceived</code> \u2192 Billing plugin updates records</li> </ul>"},{"location":"plugins/plugin-system/#2-operator-api-lane","title":"2. Operator API Lane","text":"<p>Purpose: Synchronous request/response between plugins</p> API CallPolicy Enforcement <pre><code># Get user details from identity service\nresponse = await plugin.call_operator(\n    target=\"identity-service\",\n    method=\"GET\",\n    path=\"/users/123\"\n)\nuser_data = response.json()\n</code></pre> <pre><code># Core validates before forwarding\n- caller_traits: [\"user_manager\"]\n- target_endpoint: \"/users/{id}\"\n- required_permissions: [\"read_user\"]\n</code></pre> <p>Security Governance</p> <p>The core's policy engine validates every operator call, checking plugin traits and user permissions before forwarding requests.</p>"},{"location":"plugins/plugin-system/#3-proxy-lane","title":"3. Proxy Lane","text":"<p>Purpose: Controlled external API access with domain allowlisting</p> External API CallDomain Allowlist <pre><code># Call external service through proxy\nresponse = await plugin.proxy_request(\n    url=\"https://api.example.com/data\",\n    method=\"GET\",\n    headers={\"API-Key\": \"secret\"}\n)\n</code></pre> <pre><code>{\n  \"allowed_domains\": [\n    \"api.salesforce.com\",\n    \"hooks.slack.com\",\n    \"api.stripe.com\"\n  ]\n}\n</code></pre> <p>Restricted Access</p> <p>Only plugins with <code>external_service</code> trait can use the proxy lane. All calls are logged and filtered through domain allowlists.</p>"},{"location":"plugins/plugin-system/#plugin-manifest-system","title":"Plugin Manifest System","text":"<p>Every plugin declares its capabilities through a comprehensive manifest that undergoes strict security validation.</p>"},{"location":"plugins/plugin-system/#core-manifest-structure","title":"Core Manifest Structure","text":"<pre><code>{\n  \"id\": \"user-management\",\n  \"name\": \"User Management Service\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Manages user profiles and authentication\",\n  \"contracts\": [\"IdentityPlugin\"],\n  \"traits\": [\"handles_pii\", \"audit_required\"],\n  \"security\": {\n    \"authentication_required\": true,\n    \"data_classification\": [\"pii\"]\n  },\n  \"compliance\": {\n    \"hipaa_controls\": [\"164.312(a)\"],\n    \"audit_level\": \"detailed\"\n  }\n}\n</code></pre>"},{"location":"plugins/plugin-system/#manifest-fields-reference","title":"Manifest Fields Reference","text":"<ul> <li>id \u2013 A unique identifier for the plugin. This is a short string (only lowercase letters, numbers, or hyphens are allowed) GitHub. It\u2019s used as the plugin\u2019s key in the system (e.g., other plugins might refer to this ID if they depend on it). Example: <code>\"user-management\"</code> is the ID of the User Management plugin GitHub.</li> <li>name \u2013 Human-readable name of the plugin. Can include spaces or mixed case. This is for display purposes (e.g., in UIs or logs) and can be more descriptive than the ID.</li> <li>version \u2013 The plugin\u2019s version string, following semantic versioning (MAJOR.MINOR.PATCH) GitHub. This helps manage compatibility and upgrades. Example: <code>\"1.0.0\"</code> for a stable initial release GitHub.</li> <li>description \u2013 A short description of what the plugin does. This field may be optional in the manifest schema, but it\u2019s highly recommended to include it for clarity. For example: <code>\"Manages user profiles and extended attributes\"</code> GitHub.</li> <li>contracts \u2013 A list of interface contracts the plugin implements. Contracts define the type of plugin in terms of functionality. Vivified defines several standard plugin interfaces, such as:</li> <li><code>\"IdentityPlugin\"</code> for plugins that manage user identities (accounts, profiles, authentication data) \u2013 e.g. a User Management plugin would use this.</li> <li><code>\"CommunicationPlugin\"</code> for plugins that handle messaging or notifications (e.g. email/SMS sender, chat integrations). Such plugins would implement methods like <code>send_message</code> and <code>receive_messages</code> GitHub.</li> <li><code>\"StoragePlugin\"</code> for plugins that provide data storage capabilities (e.g. file storage, database connectors), implementing methods like <code>store</code>, <code>retrieve</code>, <code>delete</code> GitHub.</li> </ul> <p>By declaring a contract, a plugin tells the core (and other plugins) what general role it plays. The manifest can list multiple contracts if applicable. For instance, a plugin might serve both as an Identity provider and a Communication provider, implementing both interfaces. The platform may enforce certain expectations based on contracts \u2013 e.g., if you claim to be an <code>IdentityPlugin</code>, you should provide certain API endpoints or behaviors. (Currently, valid contract names are limited to the known interface classes: <code>CommunicationPlugin</code>, <code>StoragePlugin</code>, <code>IdentityPlugin</code> GitHub.)</p> <ul> <li>traits \u2013 A list of traits that describe the plugin\u2019s capabilities, security posture, and requirements. Traits are essentially flags or labels that inform the core\u2019s policy engine and UI about what the plugin can do or needs. Some examples:</li> <li><code>\"handles_pii\"</code> \u2013 The plugin handles Personally Identifiable Information.</li> <li><code>\"handles_phi\"</code> \u2013 The plugin handles Protected Health Information (health data under HIPAA).</li> <li><code>\"audit_required\"</code> \u2013 All actions by this plugin must be audited (logged in detail).</li> <li><code>\"external_service\"</code> \u2013 The plugin connects to external services or APIs.</li> </ul> <p>(There are many possible traits; the platform has a registry of them covering roles, capabilities, data sensitivity, compliance needs, etc. GitHub GitHub)</p> <p>Every plugin is required to have at least one trait GitHub, and certain trait combinations are enforced. For example, if a plugin declares it <code>\"handles_pii\"</code>, it is expected to also include <code>\"audit_required\"</code> (the system requires audit logs for any plugin processing PII) GitHub GitHub. Likewise, a plugin with <code>\"handles_phi\"</code> (health data) must have <code>\"phi\"</code> in its data classification (explained below) and provide HIPAA controls (explained under compliance) GitHub GitHub. Some traits may be forbidden for security reasons \u2013 e.g., traits like <code>\"admin\"</code>, <code>\"system\"</code>, or <code>\"root\"</code> are reserved or considered dangerous and will be rejected if a plugin tries to register with them GitHub. Essentially, traits paint a picture of the plugin\u2019s profile, which the platform uses to make security decisions and to present info in the UI (each trait can have a user-friendly label and icon).</p> <ul> <li> <p>dependencies \u2013 A list of other plugin IDs that this plugin depends on. If your plugin needs another plugin to be present (for example, an \u201cHR Onboarding\u201d plugin might depend on an <code>\"identity-service\"</code> plugin for creating user accounts, or on an <code>\"email-sender\"</code> plugin to send welcome emails), list those plugin IDs here. At registration, Vivified will check these dependencies and can warn or prevent startup if required plugins are missing GitHub. In the manifest, dependencies are just the IDs (strings). They should match exactly the id of the required plugin. (The system may also check for circular dependencies and format validity GitHub.)</p> </li> <li> <p>allowed_domains \u2013 A list of external domains (hostnames) this plugin is allowed to contact. This is relevant if the plugin needs to call external APIs or services outside the Vivified platform. By default, plugins are assumed not to call external URLs, so this list is usually empty (as in the example plugin) GitHub. If the plugin does need web access, you must list every domain or host it will communicate with (e.g., if a plugin calls an external CRM at <code>api.salesforce.com</code>, that domain should appear here). The core will block any outbound call from the plugin that isn\u2019t to an allowed domain GitHub. Additionally, some domains are always blocked for security (e.g. localhost, 127.0.0.1, known malware or phishing domains) \u2013 those should not be in allowed list GitHub. The platform also validates domain formats (no wildcards or invalid names) GitHub GitHub. This mechanism is part of the \u201cProxy Lane\u201d security: if a plugin tries to use the core as a proxy to reach the internet, the core will only permit connections to trusted domains specified here.</p> </li> <li> <p>endpoints \u2013 A mapping of endpoint names to URL paths that the plugin exposes. This helps the core (and developers/users) know what URLs the plugin is listening on. Common endpoints are a health check or specific API routes. For example, the user management plugin\u2019s manifest includes: <code>\"endpoints\": { \"health\": \"/health\", \"user_info\": \"/api/users/{id}\" }</code> GitHub. This tells us the plugin serves an HTTP GET at <code>/health</code> for health checks, and a GET at <code>/api/users/{id}</code> to fetch user info. Endpoints can be RESTful paths, webhook URLs, etc., depending on plugin purpose. In the future, the core\u2019s API gateway might use this info to route requests (for instance, if the core receives an API call for a user profile, it knows to forward it to the plugin providing the <code>\"user_info\"</code> endpoint). For now, endpoints are mainly informational and for conventions \u2013 plugins still need to implement and run an API server internally to handle these routes.</p> </li> <li> <p>security \u2013 An object detailing security-related settings for the plugin. Two fields here are required for all plugins GitHub:</p> </li> <li>authentication_required \u2013 A boolean indicating if the plugin\u2019s endpoints require authentication. This must be true for all real plugins in Vivified GitHub. Essentially, plugins should not expose unauthenticated APIs (except maybe health checks). If a plugin set this to false, the core\u2019s validator will reject the registration, because all plugin interactions should be authenticated by design.</li> <li>data_classification \u2013 A list of data sensitivity levels that the plugin handles. The allowed values are <code>\"public\"</code>, <code>\"internal\"</code>, <code>\"confidential\"</code>, <code>\"pii\"</code> (Personal Identifiable Info), and <code>\"phi\"</code> (Protected Health Info) GitHub. The plugin developer should choose the highest classification of data the plugin deals with. For example, a plugin that only handles non-sensitive configuration might be <code>\"internal\"</code>, but a plugin managing user profiles would likely include <code>\"pii\"</code>. If <code>\"phi\"</code> or <code>\"pii\"</code> are included, the plugin should also have the corresponding <code>handles_phi</code>/<code>handles_pii</code> traits as mentioned above, to be consistent. The platform will validate this consistency \u2013 e.g., if you claim to handle PHI but don\u2019t classify data as <code>\"phi\"</code>, or vice versa, registration will fail GitHub. Likewise, if a plugin has an <code>\"external_service\"</code> trait, the security section should probably include an <code>allowed_domains</code> list (or else the validator will complain that an external-service plugin provided no allowed domains) GitHub.</li> </ul> <p>The security section can include additional fields as well. For instance, network isolation settings or similar flags could appear (the manifest schema expects at least the two above, but the code also mentions a <code>network_isolation</code> flag as something to enforce GitHub). In future, this might indicate if the plugin should run in a stricter sandbox network. For now, focus on auth and data classification which are mandatory. The platform\u2019s security validator will examine this section thoroughly on registration, ensuring these rules are met (authentication must be required; data classification must be provided and valid) GitHub.</p> <ul> <li>compliance \u2013 An object for compliance and regulatory requirements. In the manifest, it requires at least:</li> <li>hipaa_controls \u2013 an array of HIPAA control identifiers that the plugin adheres to (if it handles health data) GitHub. These are typically citations of regulations, like <code>\"164.312(a)\"</code> or other HIPAA rule references. If the plugin doesn\u2019t deal with PHI, this can be an empty list or a set of relevant controls for other data types. However, if the plugin has <code>handles_phi</code> trait, it must list at least one applicable HIPAA control to show how it complies GitHub. The format of these control strings is validated (they expect a pattern like numbers and subsections) GitHub.</li> <li>audit_level \u2013 a string indicating how much auditing is required for this plugin\u2019s operations GitHub. Allowed values are <code>\"none\"</code>, <code>\"basic\"</code>, <code>\"detailed\"</code>, or <code>\"complete\"</code>. This setting tells the core how extensively to log actions involving this plugin. For example, <code>\"basic\"</code> might log only key events, whereas <code>\"detailed\"</code> logs every request/response, and <code>\"complete\"</code> could even include full data dumps for compliance. In practice, a plugin that handles sensitive data would at least be <code>\"detailed\"</code>. The example plugin sets <code>audit_level: \"detailed\"</code> meaning it requires comprehensive audit logs GitHub.</li> </ul> <p>The compliance section might also include other fields such as data retention requirements. For instance, the platform\u2019s security rules expect that PHI data is retained for a minimum period (7 years, per HIPAA rules) GitHub. If a plugin handles PHI, it should ideally specify a <code>data_retention_days</code> in compliance (and the system would enforce a minimum of 2555 days) GitHub. If not specified, a default or separate policy might apply, but it\u2019s good practice to document it. (This particular field wasn\u2019t in the manifest schema we saw GitHub, but the validator code hints at such a check).</p> <ul> <li> <p>health_check \u2013 (Optional) A configuration for health monitoring of the plugin. If provided, the core will automatically start periodically checking the plugin\u2019s health using this info GitHub GitHub. Typically this would be a dictionary specifying how to check health, e.g., <code>{ \"type\": \"http\", \"port\": 8080, \"path\": \"/health\" }</code> meaning the core should perform an HTTP GET on the plugin\u2019s <code>/health</code> endpoint at port 8080. If not specified, the core may simply mark the plugin as \u201chealthy\u201d upon registration and rely on basic heartbeat or manual checks. In our Phase\u00a01 example, the plugin did not include a <code>health_check</code> field in manifest (so health monitoring wasn\u2019t auto-started), but it does expose a <code>/health</code> endpoint that could be used. The platform\u2019s health monitor supports different types: <code>\"http\"</code> (default), <code>\"tcp\"</code> ping, or <code>\"custom\"</code> checks GitHub. Using HTTP type, it expects an HTTP 200 response from the health endpoint and can even parse JSON to gather metrics like uptime, memory, etc., if the plugin provides them GitHub. If the response is not OK, or times out, the core will mark the plugin as degraded or unhealthy accordingly. This mechanism is important for production environments to detect failing plugins automatically.</p> </li> <li> <p>resources \u2013 (Optional, advanced) Resource limit specifications for the plugin. This field may not appear in all manifests, but it\u2019s recommended to include if you want to enforce that a plugin does not exceed certain CPU or memory usage. For example, a plugin manifest might have:</p> </li> </ul> <pre><code>\"resources\": {\n    \"memory_limit\": 512,\n    \"cpu_limit\": 1.0\n}\n</code></pre> <p>meaning the plugin container should be limited to 512 MB of RAM and 1 CPU core. The Vivified platform\u2019s validator will check these values if provided. It requires a minimum of 64 MB memory (anything less is considered too low and will be flagged) and allows up to 8192 MB = 8 GB max GitHub. For CPU, it expects at least 0.1 (a tenth of a core) and at most 8.0 cores GitHub. If the values are out of range or not numbers, registration will fail with an error like \"Memory limit too low\" etc. This ensures that plugins run within reasonable resource bounds and one plugin cannot starve the system of resources. (These limits may be enforced via container runtime settings in deployment.)</p> <p>As we can see, the manifest is quite comprehensive. The code is the source of truth, and the platform will validate the manifest strictly against these expectations. If any required field is missing or something doesn\u2019t pass validation, the plugin will not be allowed to register. For instance, forgetting to include a <code>data_classification</code> or leaving <code>traits</code> empty will result in a 400 Bad Request during registration GitHub GitHub. Similarly, using an invalid plugin id (wrong format) or a duplicate id will be rejected GitHub GitHub.</p>"},{"location":"plugins/plugin-system/#security-validation-of-manifests","title":"Security Validation of Manifests","text":"<p>When a plugin registers, Vivified performs comprehensive security checks on the manifest before accepting it. Here are the critical rules enforced:</p> <ul> <li>Authentication: <code>security.authentication_required</code> must be true. The platform does not allow plugins with unauthenticated endpoints GitHub. This is a fundamental rule \u2013 all plugin interactions are expected to be within an authenticated context (usually using the token the core issues to the plugin, more on that soon).</li> <li>Data Classification: <code>security.data_classification</code> must be provided and cannot be empty GitHub. The values in it must be one of the allowed categories (no made-up categories). If a plugin handles sensitive info, it needs to be explicitly classified as such.</li> <li>Trait Requirements: The plugin must declare at least one trait GitHub. Certain traits have built-in requirements:</li> <li>If <code>\"handles_phi\"</code> trait is present, the plugin\u2019s data classification must include <code>\"phi\"</code> GitHub and the <code>compliance.hipaa_controls</code> list cannot be empty GitHub.</li> <li>If <code>\"handles_pii\"</code> trait is present, data classification must include <code>\"pii\"</code> GitHub.</li> <li>If <code>\"external_service\"</code> trait is present, the plugin\u2019s <code>security.allowed_domains</code> list must not be empty (you have to specify which domains it will call) GitHub.</li> </ul> <p>Traits that are considered dangerous or reserved (like <code>\"admin\"</code>, <code>\"root\"</code>, <code>\"system\"</code>) will cause validation to fail \u2013 these traits are not allowed for plugins GitHub (they are meant for internal roles or could imply too much privilege).</p> <p>The platform also uses a trait validator to ensure there are no conflicting traits or missing prerequisites. For example, if a plugin has a compliance trait like <code>\"gdpr_compliant\"</code>, it might be required to also have <code>\"handles_pii\"</code> and <code>\"audit_required\"</code> (depending on how traits are defined in the registry) GitHub. These relationships are checked so that the plugin\u2019s trait set is internally consistent.</p> <ul> <li>Network Security: If the plugin lists <code>allowed_domains</code>, each domain is vetted:</li> <li>It cannot be on a blocked list (like localhost or known malicious domains) GitHub.</li> <li>It should not match suspicious patterns (like an IP in a private range, which might indicate an attempt to bypass security) GitHub.</li> <li> <p>It must be a valid domain format (no illegal characters or overly long names, etc.) GitHub GitHub.</p> </li> <li> <p>Compliance: If sensitive data traits are present, compliance info must be present. E.g., PHI -&gt; require HIPAA controls, as noted. Also if there\u2019s a policy that PHI data needs a certain retention, the manifest should reflect that (or the platform may enforce it automatically).</p> </li> <li>Resource Limits: While optional, if provided, they are checked for sane values as described above (not too low or too high) GitHub GitHub. This prevents misconfiguration like a typo that gives a plugin unlimited memory.</li> <li>Dependency Format: Each listed dependency should be a valid plugin ID format (simple lowercase string with no spaces) GitHub. Although the system might not fully verify that those plugins exist at registration time (in Phase 1 it just warns if missing), it does ensure no weird characters are in the dependency names. In future, it may block registration until dependencies are present or handle ordering.</li> </ul> <p>If any of these checks fail, the core will respond with an error detailing what was wrong (making it easier for developers to fix their manifest). For example, if you forgot a required field you might get <code>\"Invalid manifest format: field X is required\"</code> or if your trait combo is wrong you might get <code>\"Security validation failed: Plugin with handles_phi trait must declare 'phi' in data_classification\"</code> GitHub. Ensuring the manifest meets all criteria is crucial for a successful plugin registration.</p>"},{"location":"plugins/plugin-system/#plugin-lifecycle-registration-health-and-management","title":"Plugin Lifecycle: Registration, Health, and Management","text":""},{"location":"plugins/plugin-system/#registration-flow","title":"Registration Flow","text":"<p>When a new plugin starts up, it registers itself with the core. In Vivified, the core provides an HTTP endpoint <code>POST /plugins/register</code> for this purpose GitHub. The plugin should call this endpoint (typically as part of its startup routine) and send its manifest JSON. If the manifest passes validation, the core responds with a registration success message.</p> <p>The response includes a plugin token which is a JWT (JSON Web Token) that the plugin can use for authenticated communication thereafter GitHub GitHub. For example, a successful registration returns data like:</p> <pre><code>{\n  \"status\": \"registered\",\n  \"plugin_id\": \"user-management\",\n  \"token\": \"eyJhbGciOiJI...&lt;snip&gt;...XVCJ9.eyJwbHVnaW5faWQiOiJ1c2VyLW1hbmFnZW1lbnQiLCJ0eXBlIjoicGx1Z2luIiwiaXNzdWVkX2F0Ijoi...\" \n}\n</code></pre> <p>Here, <code>\"plugin_id\"</code> echoes your plugin\u2019s ID, and <code>\"token\"</code> is the secret token (JWT) that identifies your plugin GitHub. The core signs this token using its secret key. The plugin should store this token (for example, the example plugin simply puts it in an environment variable <code>PLUGIN_TOKEN</code> on startup after registration GitHub). On subsequent requests to the core (like if the plugin calls any core API or publishes events), it should present this token (usually via an HTTP <code>Authorization</code> header) so the core knows \u201cthis request is from plugin X\u201d. This token also encodes the plugin\u2019s traits/permissions, enabling the core to authorize what the plugin is allowed to do.</p> <p>If registration fails (due to manifest issues or an invalid auth token if one was required), the core will return an error (HTTP 400 or 401, etc.) and the plugin should log or handle that (the example plugin logs a failure if it doesn\u2019t get a 200 OK GitHub).</p> <p>Registration is the first step of the plugin lifecycle. Once registered, the plugin is considered \u201conline\u201d in the system. Internally, the core will add it to a registry of active plugins. In Phase 1, the plugin is immediately available and its status is marked as <code>\"registered\"</code> GitHub. (In later phases, there might be an approval step or an \u201cactivation\u201d toggle \u2013 but in the current implementation, registration = plugin is active/usable.)</p> <p>One thing to note: currently the registration endpoint is open (no authentication required to call it) GitHub. This is by design for Phase 1 to simplify development \u2013 any plugin that knows the core\u2019s address can attempt to register. In the future, this may be locked down so that only authorized developers or pre-shared keys can register new plugins. The core code already has a placeholder for a <code>registration_token</code> to be validated if provided GitHub, but by default it\u2019s not used yet (it simply allows registration if the manifest is good).</p>"},{"location":"plugins/plugin-system/#post-registration-and-status","title":"Post-Registration and Status","text":"<p>After registration, the plugin should keep running and do its job (serve its API endpoints, etc.). The core now is aware of the plugin and can start monitoring it. The plugin\u2019s status initially is \u201cregistered\u201d. Once it starts interacting (or once an admin explicitly enables it), it might be marked as \u201cactive\u201d. The distinction between registered and active is slight \u2013 basically, a plugin might register but not yet be fully trusted or used until an admin enables it. In the current scaffold, all registered plugins are effectively active immediately (there isn\u2019t a separate enable step after successful registration in Phase 1). However, code exists to handle disabling/enabling plugins administratively:</p> <ul> <li> <p>Disabling a plugin: The platform (likely an admin via UI or an automated health policy) can disable a plugin, which sets its status to \u201cdisabled\u201d. This would typically be done if a plugin is misbehaving or has a security issue. In code, disabling stops its health monitoring and marks it inactive GitHub GitHub. A disabled plugin might still be running, but the core will refuse to route any requests to it or use it, effectively quarantining it.</p> </li> <li> <p>Enabling a plugin: If a plugin was disabled (or if it was registered but not auto-enabled), an admin can enable it, setting status to \u201cactive\u201d GitHub GitHub. The core will re-validate its manifest security before enabling GitHub (to ensure nothing changed or no new policy violation) and then allow it to participate normally. If health checks were configured, those are restarted on enable GitHub.</p> </li> <li> <p>Unregistering a plugin: This typically occurs when a plugin is shutting down or being removed. The plugin or admin can call an unregister endpoint (not publicly exposed in Phase1, but the core\u2019s manager has an internal method for it) to cleanly remove it from the registry GitHub GitHub. Unregistering will mark it as inactive, stop health checks, and free any allocated resources in the core\u2019s tracking. If the plugin simply goes offline (crashes or is removed) without an unregister call, the core would eventually notice via health monitoring (see next section) and consider it unhealthy or inactive.</p> </li> </ul> <p>For end users or admins, the list of plugins (e.g., via <code>GET /plugins</code> or in the Admin UI\u2019s plugins page) will show each plugin\u2019s name, version, status, and health at a glance GitHub. In our example, after starting the core and the User Management plugin, a call to list plugins returns something like:</p> <pre><code>{\n  \"plugins\": [\n    {\n      \"manifest\": { ...plugin manifest... },\n      \"status\": \"registered\",\n      \"registered_at\": \"...timestamp...\",\n      \"last_heartbeat\": \"...timestamp...\",\n      \"token\": \"eyJ0eXAiOiJKV1Qi...\",\n      \"health\": \"unknown\"\n    }\n  ]\n}\n</code></pre> <p>(This output is from the simple registry in Phase1 GitHub; later, the enhanced manager would give more structured info). Notice the health is \u201cunknown\u201d initially \u2013 that\u2019s because we haven\u2019t done a health check yet.</p>"},{"location":"plugins/plugin-system/#health-monitoring","title":"Health Monitoring","text":"<p>Vivified includes a health monitoring subsystem to keep track of plugin health status over time. There are two ways the core can know about a plugin\u2019s health:</p> <p>1) Active Monitoring (Polling): If a plugin provides a <code>health_check</code> config in its manifest, the core will periodically perform that health check. The default strategy is an HTTP check \u2013 the core will ping the plugin\u2019s health endpoint at a set interval (e.g. every 30 seconds by default) GitHub GitHub. If the plugin responds with the expected status (200 OK) in a timely manner, it\u2019s considered healthy. If not, the core will mark it unhealthy or degraded. The health check can capture metrics too \u2013 if the plugin\u2019s <code>/health</code> returns JSON with fields like \u201cuptime\u201d, \u201cmemory_usage\u201d, etc., those get recorded for monitoring GitHub GitHub. The core\u2019s health monitor will log warnings if a plugin becomes unhealthy and even send alerts (to an alerting system or log) for critical issues GitHub GitHub.</p> <p>The health monitor uses a failure threshold (default 3 failures) to decide when a plugin is officially unhealthy GitHub GitHub. For example, one missed ping might mark the plugin status as \u201cdegraded\u201d (if it fails once or twice in a row), but after 3 consecutive failures, it marks it \u201cunhealthy\u201d GitHub. This prevents flapping (temporary issues) from causing false alarms. Once a plugin is marked unhealthy, the core can optionally take action, like disabling the plugin automatically or alerting admins. The monitoring continues in the background as long as the plugin is running. If the plugin recovers and starts responding, the status can return to healthy.</p> <p>In our Phase 1 scenario, since the User Management plugin did not specify a <code>health_check</code> in manifest, the core did not auto-enable polling for it GitHub. We rely on basic checks or manual observation. However, the plugin does have a <code>/health</code> endpoint, and we have Docker configured to check that endpoint at container level as well. In the future, adding <code>\"health_check\": {\"type\": \"http\", \"path\": \"/health\", \"port\": 8000}</code> to its manifest could allow the core to directly monitor it.</p> <p>2) Heartbeats (Passive Monitoring): A plugin can proactively send heartbeat messages to the core to say \u201cI am alive and here\u2019s my status.\u201d The core provides a <code>/plugins/heartbeat</code> endpoint (not exposed in Phase1 public API, but planned) that plugins could POST to with status info. The plugin might include its current memory usage, uptime, or simply a timestamp. The core would update the plugin\u2019s record (<code>last_heartbeat</code> timestamp and any provided metrics) GitHub GitHub. The example platform code shows that if a plugin sends a status in the heartbeat containing, say, <code>\"status\": \"active\"</code> or <code>\"health\": {metrics...}</code>, the core will merge that into the plugin\u2019s info GitHub GitHub. This mechanism is useful if the plugin has more complex internal checks and wants to inform the core. However, as of now, this is more of a future enhancement; the current plugin doesn\u2019t do this automatically.</p> <p>In summary, the health status of a plugin can be:</p> <ul> <li>healthy \u2013 responding to checks, no issues.</li> <li>degraded \u2013 missed a few checks or returned errors, but not yet failing consistently.</li> <li>unhealthy \u2013 consistently failing checks (or explicitly reported a failure). Unhealthy plugins might be automatically disabled for safety.</li> <li>unknown \u2013 not enough info yet (e.g., just registered and not checked, or health monitoring not configured).</li> </ul> <p>Administrators will be able to see this status in the UI. For example, if the User Management plugin\u2019s health endpoint was down, the core would eventually mark it unhealthy and surface an alert (in logs or UI) like \u201cPlugin user-management is unhealthy: Health check timeout\u201d GitHub GitHub.</p>"},{"location":"plugins/plugin-system/#interacting-with-plugins-after-registration","title":"Interacting with Plugins (After Registration)","text":"<p>Once a plugin is registered and active, how do we use it? There are a few scenarios:</p> <ul> <li> <p>Core to Plugin calls: The core may route certain requests to plugins. For instance, if the platform receives an API call that falls under a plugin\u2019s responsibility (like a request for user profile data), the core\u2019s GatewayService might forward that to the Identity plugin. The manifest\u2019s <code>endpoints</code> field helps core know where to send it. In Phase 1, this gateway is being set up (we see <code>gateway_service = GatewayService(...)</code> initialized on startup GitHub GitHub), but the exact routing rules may be limited. As more features roll out, the Gateway will use plugin manifests to direct traffic. The core will attach the necessary authentication (possibly the plugin\u2019s token or a system token) when proxying the request so that the plugin knows it\u2019s a legitimate call.</p> </li> <li> <p>Plugin to Core calls: Plugins can call core services or admin APIs if needed. For example, a plugin might need to fetch some configuration or use the core\u2019s identity service for authentication. For such calls, the plugin should use its token for auth. The core\u2019s auth system (AuthManager) recognizes plugin JWTs and can restrict what that plugin is allowed to do based on its traits GitHub. So if plugin A tries to do something outside its purview, the core can deny the operation. There\u2019s a method <code>validate_plugin_operation</code> in the core that checks, given a plugin\u2019s ID and an operation context, whether it\u2019s allowed GitHub GitHub. This uses rules like: a plugin marked as unhealthy or not active cannot perform operations; certain operation types might be forbidden (the code, for example, forbids dangerous operations names like \u201cdelete_all\u201d or \u201cshutdown\u201d) GitHub GitHub; and if an operation involves sensitive data (phi/pii), the plugin must have appropriate traits GitHub. This ensures one plugin can\u2019t, say, delete another plugin\u2019s data or access data it shouldn\u2019t.</p> </li> <li> <p>Plugin to Plugin calls: As mentioned in the communication model, direct plugin-to-plugin calls go through core (Operator Lane). In practical terms, one plugin would call a core endpoint, and the core will forward to the target plugin\u2019s endpoint. This is still under active development \u2013 future docs will detail specific endpoints or SDK functions for inter-plugin RPC. In Phase 1, we don\u2019t have a direct example of one plugin calling another since we only have one main plugin. But you can imagine if there was also a \u201cNotification\u201d plugin, the User Management plugin could call core -&gt; <code>/notifications/send</code> (which core would route to the Notification plugin).</p> </li> <li> <p>External calls: If a plugin needs to call out to an external API, it should do so through the core\u2019s proxy (or at least inform core). In practice, a plugin could just make an HTTP call directly (since it\u2019s just code running in a container and it could reach the internet), but that would bypass core oversight. The recommended approach (especially in future locked-down deployments) is that the plugin asks the core\u2019s gateway/proxy service to make the call on its behalf. The core would then check <code>allowed_domains</code> and either permit or block it. This aspect might not be enforced in Phase 1 (no specific code intercepting plugin\u2019s outbound calls yet, aside from the planned checks), but it\u2019s a scenario the platform is built for. So plugin developers should design with that in mind: declare your external domains, and expect that unknown calls could be filtered.</p> </li> </ul>"},{"location":"plugins/plugin-system/#management-interfaces","title":"Management Interfaces","text":"<p>For administrators (or advanced users) who are not writing code, Vivified provides tools to manage plugins:</p> <ul> <li> <p>Admin UI: There is a web-based Admin Console (built with MkDocs Material for documentation and likely a React/TypeScript app for actual admin UI) where you can see the list of plugins, their status (enabled/disabled, healthy/unhealthy), and maybe buttons to enable/disable or configure them. The UI will likely group plugins by category and show traits and compliance info in a friendly way. For example, an \u201cIdentity Plugin\u201d might show up with an icon and label, indicating it handles PII with auditing enabled, etc. Non-technical users can use this UI to turn plugins on or off, without worrying about the underlying JSON manifest details.</p> </li> <li> <p>CLI Tools: For developers or technical operators, Vivified includes a CLI (Command Line Interface) tool. For instance, there\u2019s a <code>vivified-cli</code> that has commands to validate a manifest file against the schema GitHub (useful when developing a new plugin to catch mistakes early) and even a command to scaffold a new plugin GitHub. The <code>create-plugin</code> command can generate a basic plugin directory with a <code>manifest.json</code> filled out (with default fields and placeholders) GitHub GitHub. This helps as a starting point for developers to then add their code (the CLI can create a skeleton for Python or Node plugins, for example). Over time, the CLI may grow to have commands to package, deploy, or test plugins as well.</p> </li> <li> <p>Documentation: The platform\u2019s documentation (like this content) is crucial for both non-technical users (to understand what plugins are available and what they do) and developers (to build their own). Each plugin should have its own documentation page covering its purpose, how to use it, and any APIs it provides. On the left side of the docs (if you\u2019re reading on the docs site), you will find each plugin listed. Selecting a plugin will show its details, and on the right side you\u2019ll see a Table of Contents for that plugin\u2019s doc (so you can jump to sections like overview, setup, endpoints, etc.). This structure makes it easy to navigate all plugin-related information.</p> </li> </ul> <p>Now, let\u2019s look at our concrete example plugin in this Phase 1 scaffold.</p>"},{"location":"plugins/plugin-system/#example-user-management-plugin-identityplugin","title":"Example: User Management Plugin (IdentityPlugin)","text":"<p>The User Management plugin is a simple example shipped with Vivified Phase 1. Its role is to manage user profiles or extended attributes \u2013 essentially serving as an IdentityPlugin. This plugin doesn\u2019t handle authentication (the core handles basic auth in Phase1), but it is set up to demonstrate storing extra user info and the mechanics of plugin registration.</p>"},{"location":"plugins/plugin-system/#manifest-details","title":"Manifest Details","text":"<p>Below is the manifest of the User Management plugin, as defined in its code (Python <code>main.py</code> of the plugin):</p> <pre><code>MANIFEST = {\n    \"id\": \"user-management\",\n    \"name\": \"User Management Plugin\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Manages user profiles and extended attributes\",\n    \"contracts\": [\"IdentityPlugin\"],\n    \"traits\": [\"handles_pii\", \"audit_required\"],\n    \"dependencies\": [],\n    \"allowed_domains\": [],\n    \"endpoints\": {\n        \"health\": \"/health\",\n        \"user_info\": \"/api/users/{id}\"\n    },\n    \"security\": {\n        \"authentication_required\": True,\n        \"data_classification\": [\"pii\", \"internal\"]\n    },\n    \"compliance\": {\n        \"hipaa_controls\": [\"164.312(a)\", \"164.312(d)\"],\n        \"audit_level\": \"detailed\"\n    }\n}\n</code></pre> <p>(This is taken directly from the example plugin code GitHub GitHub.)</p> <p>Let\u2019s interpret this manifest:</p> <ul> <li>id/name/version: Identifies the plugin as <code>\"user-management\"</code>, version <code>1.0.0</code>, with a clear name <code>\"User Management Plugin\"</code> GitHub.</li> <li>description: Explains that it \u201cManages user profiles and extended attributes\u201d GitHub. In practice, this could mean storing additional user information beyond what the core user system has.</li> <li>contracts: It implements <code>IdentityPlugin</code> GitHub. This means the core (and other plugins) should treat it as the source of truth for identity-related data like user profiles. If in the future there\u2019s a defined interface for <code>IdentityPlugin</code> (methods to get user info, update profiles, etc.), this plugin would implement those.</li> <li>traits: It declares <code>\"handles_pii\"</code> and <code>\"audit_required\"</code> GitHub. This makes sense: user profiles often contain personal info (names, emails, etc.), so it handles PII. And because it handles PII, by policy it has <code>audit_required</code> (the system will audit actions). These traits will ensure the core applies the right security (for instance, any operation involving this plugin\u2019s data will require an audit log entry, and only plugins/users with permission to handle PII should access it).</li> <li>dependencies: None. This plugin doesn\u2019t depend on any other plugin to function. (It might use core services like the database or core identity service for authentication, but those are not plugins, they are core components.)</li> <li>allowed_domains: None. It doesn\u2019t call external APIs. All its work is internal.</li> <li>endpoints: Two are listed:</li> <li><code>\"health\": \"/health\"</code> \u2013 the health check endpoint. Indeed, the plugin code defines a FastAPI route <code>/health</code> that returns <code>{ \"status\": \"healthy\", \"plugin\": \"user-management\" }</code> as a simple health indicator GitHub.</li> <li><code>\"user_info\": \"/api/users/{id}\"</code> \u2013 an endpoint to get user info by user ID GitHub. The plugin code implements this at <code>GET /api/users/{user_id}</code> and currently just returns a static placeholder dictionary with some fields (like department and manager for the user) GitHub. This is a stub meant to simulate extended profile data. In a real scenario, this might look up a database or another service for detailed user information (like profile photo, bio, etc.). The presence of this endpoint suggests that if another part of the system needs a user\u2019s info, it could call this plugin. For example, if the core\u2019s admin UI wants to display a user\u2019s profile, it might call the <code>IdentityPlugin</code>\u2019s <code>user_info</code> endpoint.</li> <li>security: <code>authentication_required</code> is true (so all endpoints should require a valid auth token \u2013 which is natural because only authorized requests from core or an admin should hit them), and <code>data_classification</code> is <code>[\"pii\", \"internal\"]</code> GitHub. That means the plugin deals with personal data that is internal to the company. It did not include <code>\"phi\"</code>, which is correct since user profiles aren\u2019t health records. It included <code>\"pii\"</code>, which aligns with the trait <code>handles_pii</code>. The system\u2019s validator would check and be satisfied here (<code>handles_pii</code> trait and <code>\"pii\"</code> classification match) GitHub. Had this been inconsistent, registration would error.</li> <li>compliance: It lists two HIPAA controls: <code>\"164.312(a)\"</code> and <code>\"164.312(d)\"</code> GitHub. Those correspond to sections of the HIPAA security rule (likely related to access controls and audits). This is a bit curious because we normally associate HIPAA with PHI, not just PII. Perhaps the plugin anticipates possibly handling some health-related personal info, or the developer just included an example. In any case, since it has <code>handles_pii</code> (not <code>phi</code>), technically HIPAA controls might not be strictly required. The validator would only require them if <code>handles_phi</code> was present GitHub. It doesn\u2019t hurt to include them \u2013 it signals the plugin adheres to those specific security safeguards, which is a good thing. The <code>audit_level</code> is <code>\"detailed\"</code> meaning the system will keep detailed logs for this plugin\u2019s operations, fitting the <code>audit_required</code> trait it has.</li> <li>health_check: Not explicitly in the manifest, so by default none. If we wanted, we could add <code>\"health_check\": {\"type\": \"http\", \"port\": 8000, \"path\": \"/health\"}</code>. Port 8000 is the default where this FastAPI app runs (as per Docker compose, it doesn\u2019t explicitly publish a port internally, but if core were to call it, it\u2019d use the Docker network). The health monitor in core would then call <code>http://user-management:8000/health</code> periodically. However, since it\u2019s omitted, core didn\u2019t set up polling. We rely on the fact that the plugin calls core on startup (register) and after that core assumes it\u2019s up. The Docker environment does ensure if the plugin dies, you\u2019d see it in docker-compose output, and you could manually notice it\u2019s not responding.</li> </ul>"},{"location":"plugins/plugin-system/#plugin-core-logic","title":"Plugin Core Logic","text":"<p>Aside from manifest and registration, the User Management plugin\u2019s code is very minimal:</p> <ul> <li>It configures a FastAPI app with the title \"User Management Plugin\".</li> <li>On startup event, it triggers the <code>register_with_core()</code> coroutine which uses an HTTP client to <code>POST</code> the manifest to the core\u2019s <code>/plugins/register</code> endpoint GitHub. If successful (HTTP 200), it logs a success and stores the returned token in the environment for later use GitHub. If it fails, it logs an error. This means as soon as you bring up this plugin (via <code>docker-compose up</code> or <code>make up</code> as per the readme GitHub), it will immediately announce itself to the core.</li> <li>It defines the <code>GET /health</code> route returning a simple JSON (status healthy) GitHub.</li> <li>It defines the <code>GET /api/users/{user_id}</code> route returning a sample payload with a few made-up fields (department, manager, traits) for that user ID GitHub.</li> <li>It doesn\u2019t interact with a database or the core\u2019s identity service in this example. In a more fleshed-out scenario, one might expect it to query the core\u2019s database for the user info or maintain its own data store. But for Phase 1, the goal was to exercise the plugin interface \u2013 i.e., show that a plugin can register and expose an endpoint.</li> </ul>"},{"location":"plugins/plugin-system/#using-the-user-management-plugin","title":"Using the User Management Plugin","text":"<p>As an end-user or admin, what does this plugin provide?</p> <ul> <li>It offers an API to get extended user info. In the current state, this is just a placeholder, so it\u2019s not very useful to an end-user yet. In future, if an admin adds custom fields to user profiles or if there\u2019s an HR system integration, this plugin would be the place to handle that. For now, consider it a stub for demonstration.</li> <li>It could be extended to allow creating or updating user info (e.g., a <code>POST /api/users</code> to create a profile). That would be logical for an identity management plugin, though not implemented yet.</li> <li>It registers itself so that the core knows an <code>IdentityPlugin</code> is present. This is important: if down the line another plugin or module checks \u201cdo we have any <code>IdentityPlugin</code> in the system?\u201d the answer is yes, <code>user-management</code> is serving that role. For example, maybe a plugin that handles authentication or auditing might behave differently if an <code>IdentityPlugin</code> is present (perhaps to fetch user names for audit logs). The presence of the contract in manifest allows such dynamic behavior.</li> </ul> <p>Admin perspective: In the Admin UI, you would see User Management Plugin listed. It might show that it implements the Identity contract, handles PII (with an icon or tag indicating that), and is audited. If you click on it, you might see details like version 1.0.0, description, and the health status. There\u2019s also likely a way to hit a \"Test health\" or see metrics (which would just show it\u2019s healthy if running). If the plugin was not running, the UI would flag it as not responding.</p> <p>Developer perspective: If you\u2019re creating a similar plugin, this is your template. You\u2019d ensure to define a manifest with all fields and call core on startup. The rest is just building out your plugin\u2019s own API logic.</p>"},{"location":"plugins/plugin-system/#conclusion-and-next-steps","title":"Conclusion and Next Steps","text":"<p>We\u2019ve covered every aspect of the Vivified plugin system as of the current design and Phase 1 implementation \u2013 from what plugins are and why they\u2019re useful, to the exact manifest format and security model, to how the core and plugins interact during registration and runtime. The code is the source of truth, and we\u2019ve based this documentation directly on the code and configuration of the Vivified platform GitHub GitHub, ensuring accuracy.</p> <p>For Vivified users (especially those less technical): you should now have an understanding that plugins are like add-on apps for Vivified \u2013 you can plug in new capabilities and the platform ensures they run safely. You\u2019ll typically manage them through a UI by turning them on/off and trusting the platform to handle the rest.</p> <p>For developers: you have a full reference to build your own plugin. Remember to include all required manifest fields, follow the security guidelines (don\u2019t forget authentication and data classification!), and test your manifest with the CLI validator. Use the example as a starting point, and consider using the provided SDKs or templates (Vivified might provide base images or client libraries to make building plugins easier \u2013 e.g., a Python base that already knows how to register with core, etc., as hinted in the plan GitHub).</p> <p>Finally, as Vivified evolves, more plugins will be introduced (for communications, storage, analytics, etc.), each with their own documentation. The plugin system is central to Vivified\u2019s flexibility. By having comprehensive documentation of every possible detail here, we ensure that our AI assistant (and any Retrieval-Augmented Generation system indexing these docs) can answer any question about plugins \u2013 from \u201cHow do I declare a plugin that stores PHI?\u201d to \u201cWhat happens if a plugin fails its health checks?\u201d \u2013 with accuracy. If anything changes in code, those changes should be reflected in updated documentation to keep this as the single source of truth for the plugin system.</p>"},{"location":"plugins/rag-db-plugin/","title":"RAG Database Plugin (Operator Backend)","text":"<p>This guide defines a minimal operator\u2011lane contract for a RAG storage/search plugin. Use it to back Vivified\u2019s semantic search with your own database (e.g., Postgres + pgvector, Elastic, Milvus).</p>"},{"location":"plugins/rag-db-plugin/#why","title":"Why","text":"<ul> <li>Enterprise control: keep embeddings and content chunks in your infra.</li> <li>Scale and latency: use native ANN/vector indexes (pgvector/FAISS/RediSearch).</li> <li>TBAC: enforce trait filters at the data tier.</li> </ul>"},{"location":"plugins/rag-db-plugin/#contract-operations","title":"Contract (Operations)","text":"<p>Expose these operations via your plugin and declare them in <code>manifest.endpoints</code>:</p> <ul> <li><code>rag_index</code> \u2192 <code>POST /rag/index</code></li> <li>Request (Core \u2192 Plugin):     <pre><code>{\n  \"id\": \"docBase:chunk\",\n  \"title\": \"path/to/file#chunkN\",\n  \"path\": \"abs/or/relative/path\",\n  \"content\": \"chunk text\",\n  \"required_traits\": [\"...\"],\n  \"classification\": [\"internal\"],\n  \"vector\": [0.1, 0.2, ...]  // optional\n}\n</code></pre></li> <li> <p>Response: <code>{ \"ok\": true }</code></p> </li> <li> <p><code>rag_query</code> \u2192 <code>POST /rag/query</code></p> </li> <li>Request (Core \u2192 Plugin):     <pre><code>{ \"q\": \"question\", \"top_k\": 5, \"user_traits\": [\"...\"] }\n</code></pre></li> <li>Response:     <pre><code>{\n  \"items\": [\n    {\"id\":\"...\",\"title\":\"...\",\"path\":\"path/to/file#chunk\",\"score\":0.83}\n  ]\n}\n</code></pre></li> </ul> <p>Core calls these via the operator lane:</p> <pre><code>POST /gateway/{plugin_id}/rag_index { caller_plugin: \"ai-core\", payload: {...} }\nPOST /gateway/{plugin_id}/rag_query { caller_plugin: \"ai-core\", payload: {...} }\n</code></pre>"},{"location":"plugins/rag-db-plugin/#implementation-outline","title":"Implementation Outline","text":"<ul> <li>Storage</li> <li><code>documents(id PRIMARY KEY, title, path, required_traits JSONB, classification JSONB)</code></li> <li><code>chunks(doc_id, chunk_no, content, vector VECTOR(1536))</code> (pgvector) + ANN index</li> <li>Ingest (rag_index)</li> <li>Upsert doc metadata</li> <li>Insert chunk with embedding</li> <li>Query (rag_query)</li> <li>Compute embedding for <code>q</code> or accept <code>vector</code> if you run your own embedder</li> <li><code>SELECT ... ORDER BY vector &lt;-&gt; $qvec LIMIT $top_k</code></li> <li>Filter by TBAC: <code>WHERE required_traits \u2286 user_traits</code></li> </ul>"},{"location":"plugins/rag-db-plugin/#wiring-steps","title":"Wiring Steps","text":"<ol> <li>Build plugin container listening on <code>:8080</code> with endpoints above.</li> <li>Manifest <code>endpoints: { \"rag_index\": \"/rag/index\", \"rag_query\": \"/rag/query\" }</code> (plus optional <code>host</code>/<code>port</code>).</li> <li>Register plugin: Admin Console \u2192 Plugins \u2192 Register.</li> <li>Set operator allowlist: <code>PUT /admin/operator/allowlist { caller: \"ai-core\", target: \"your-plugin-id\", operations: [\"rag_index\",\"rag_query\"] }</code> (UI: Plugin Dev Guide \u2192 Generate Operator Allowlist).</li> <li>In Admin Console \u2192 AI Studio \u2192 Ingestion Rules \u2192 RAG Settings: set <code>Backend=Plugin</code> and <code>Plugin ID</code> to your plugin id.</li> <li>Train RAG (AI Studio) and run queries.</li> </ol>"},{"location":"plugins/rag-db-plugin/#security-and-compliance","title":"Security and Compliance","text":"<ul> <li>No PHI/PII in logs; store doc previews only if compliant.</li> <li>Encrypt at rest and enforce row\u2011level filters if multi\u2011tenant.</li> <li>Audit all operator calls (Core already emits <code>operator_call</code>).</li> </ul>"},{"location":"plugins/rag-db-plugin/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>403 on <code>/gateway/...</code> \u2192 missing operator allowlist. Add operations for caller <code>ai-core</code> \u2192 your plugin.</li> <li>Zero results \u2192 verify embeddings, confirm TBAC filters, test with broad traits.</li> <li>Latency spikes \u2192 add ANN index, batch index, tune chunk size/overlap.</li> </ul>"},{"location":"plugins/sdk/","title":"Plugin SDK Reference","text":"<p>The Vivified platform provides SDKs in multiple languages to simplify plugin development. Each SDK handles authentication, communication protocols, and provides helper utilities for common tasks.</p> <ul> <li> <p>:material-language-python:{ .lg .middle } Python SDK</p> <p>Full-featured SDK with async support and type hints</p> </li> <li> <p>:material-nodejs:{ .lg .middle } Node.js SDK</p> <p>Complete JavaScript/TypeScript SDK with full plugin capabilities</p> </li> <li> <p>:material-language-go:{ .lg .middle } Go SDK</p> <p>High-performance SDK (Coming Soon - Q1 2025)</p> </li> </ul>"},{"location":"plugins/sdk/#installation","title":"Installation","text":"PythonNode.jsGo <pre><code>pip install vivified-plugin-sdk\n</code></pre> <pre><code>npm install @vivified/plugin-sdk\n# or\nyarn add @vivified/plugin-sdk\n</code></pre> <pre><code># Coming Soon - Q1 2025\ngo get github.com/vivified/plugin-sdk-go\n</code></pre>"},{"location":"plugins/sdk/#quick-start","title":"Quick Start","text":""},{"location":"plugins/sdk/#python-sdk-example","title":"Python SDK Example","text":"<pre><code>from vivified_sdk import Plugin, PluginManifest\nfrom vivified_sdk.traits import Traits\nfrom vivified_sdk.contracts import StoragePlugin\n\nclass MyPlugin(Plugin, StoragePlugin):\n    def __init__(self):\n        manifest = PluginManifest(\n            id=\"my-plugin\",\n            name=\"My Storage Plugin\",\n            version=\"1.0.0\",\n            contracts=[\"StoragePlugin\"],\n            traits=[Traits.HANDLES_PII, Traits.AUDIT_REQUIRED]\n        )\n        super().__init__(manifest)\n\n    async def store(self, key: str, data: bytes) -&gt; bool:\n        \"\"\"Implement storage interface\"\"\"\n        # Your implementation here\n        return True\n\n    async def retrieve(self, key: str) -&gt; bytes:\n        \"\"\"Implement retrieval interface\"\"\"\n        # Your implementation here\n        return b\"\"\n\n# Run the plugin\nif __name__ == \"__main__\":\n    plugin = MyPlugin()\n    plugin.run()\n</code></pre>"},{"location":"plugins/sdk/#nodejs-sdk-example","title":"Node.js SDK Example","text":"<pre><code>const { Plugin, PluginManifest, Traits } = require('@vivified/plugin-sdk');\n\nclass MyPlugin extends Plugin {\n    constructor() {\n        const manifest = new PluginManifest({\n            id: 'my-plugin',\n            name: 'My Storage Plugin',\n            version: '1.0.0',\n            contracts: ['StoragePlugin'],\n            traits: [Traits.HANDLES_PII, Traits.AUDIT_REQUIRED]\n        });\n        super(manifest);\n    }\n\n    async store(key, data) {\n        // Your implementation here\n        return true;\n    }\n\n    async retrieve(key) {\n        // Your implementation here\n        return Buffer.from('');\n    }\n}\n\n// Run the plugin\nconst plugin = new MyPlugin();\nplugin.run();\n</code></pre>"},{"location":"plugins/sdk/#go-sdk-coming-soon","title":"Go SDK (Coming Soon)","text":"<pre><code>// Coming Q1 2025 - Full Go SDK with complete feature parity\npackage main\n\nimport (\n    \"github.com/vivified/plugin-sdk-go\"\n)\n\ntype MyPlugin struct {\n    plugin.Base\n}\n\nfunc main() {\n    manifest := plugin.NewManifest(\n        \"my-plugin\",\n        \"My Storage Plugin\",\n        \"1.0.0\",\n    )\n    p := &amp;MyPlugin{}\n    plugin.Run(p, manifest)\n}\n</code></pre>"},{"location":"plugins/sdk/#core-components","title":"Core Components","text":""},{"location":"plugins/sdk/#plugin-manifest","title":"Plugin Manifest","text":"<p>The manifest declares your plugin's capabilities and requirements:</p> Field Type Required Description <code>id</code> string Yes Unique plugin identifier <code>name</code> string Yes Human-readable name <code>version</code> string Yes Semantic version <code>contracts</code> array Yes Implemented interfaces <code>traits</code> array Yes Plugin capabilities/requirements <code>security</code> object Yes Security configuration <code>allowed_domains</code> array No External domains for proxy access"},{"location":"plugins/sdk/#communication-apis","title":"Communication APIs","text":""},{"location":"plugins/sdk/#event-bus-canonical-lane","title":"Event Bus (Canonical Lane)","text":"PythonNode.jsGo <pre><code># Emit an event\nawait plugin.emit_event(\"user.created\", {\n    \"user_id\": \"123\",\n    \"email\": \"user@example.com\"\n})\n\n# Listen for events\n@plugin.on_event(\"document.processed\")\nasync def handle_document(event):\n    print(f\"Document {event.document_id} processed\")\n</code></pre> <pre><code>// Emit an event\nawait plugin.emitEvent('user.created', {\n    userId: '123',\n    email: 'user@example.com'\n});\n\n// Listen for events\nplugin.onEvent('document.processed', async (event) =&gt; {\n    console.log(`Document ${event.documentId} processed`);\n});\n</code></pre> <pre><code>// Coming Soon - Q1 2025\n// Full event bus integration\n</code></pre>"},{"location":"plugins/sdk/#sdk-features","title":"SDK Features","text":""},{"location":"plugins/sdk/#all-sdks-provide","title":"All SDKs Provide:","text":"<ul> <li>\u2705 Authentication - Automatic token management</li> <li>\u2705 Health Checks - Built-in health monitoring</li> <li>\u2705 Configuration - Dynamic configuration updates</li> <li>\u2705 Storage Integration - Encrypted storage service access</li> <li>\u2705 Event Bus - Canonical event publishing/subscription</li> <li>\u2705 Operator API - Inter-plugin communication</li> <li>\u2705 Proxy Service - Filtered external API access</li> <li>\u2705 Audit Logging - Automatic audit trail generation</li> <li>\u2705 Error Handling - Standardized error types</li> <li>\u2705 Testing Utilities - Unit and integration test helpers</li> </ul>"},{"location":"plugins/sdk/#sdk-version-compatibility","title":"SDK Version Compatibility","text":"SDK Current Version Min Core Version Status Python 1.0.0 1.0.0 \u2705 Stable Node.js 1.0.0 1.0.0 \u2705 Stable Go - 1.0.0 \ud83d\udea7 Coming Q1 2025 Rust - 1.0.0 \ud83d\udcc5 Planned Q2 2025 Java - 1.0.0 \ud83d\udcc5 Planned Q2 2025"},{"location":"plugins/sdk/#resources","title":"Resources","text":"<ul> <li>API Documentation: Full SDK API reference for each language</li> <li>Example Plugins: Plugin Examples</li> <li>Development Guide: Plugin Development</li> <li>GitHub: github.com/vivified/plugin-sdk</li> </ul>"},{"location":"policy/operator-allowlist/","title":"Operator Allowlist","text":"<p>Operator lane calls are synchronous RPC from one plugin (or Core) to another, brokered by Core. The operator allowlist defines which operations a caller may invoke on a target.</p>"},{"location":"policy/operator-allowlist/#keys","title":"Keys","text":"<p>Config key pattern: <code>operator.allow.&lt;caller-&gt;target&gt;</code> with a JSON array of operation names.</p> <p>Example:</p> <pre><code>operator.allow.ai-core-&gt;rag-db = [\"rag_index\", \"rag_query\"]\n</code></pre>"},{"location":"policy/operator-allowlist/#admin-api","title":"Admin API","text":"<ul> <li>GET <code>/admin/operator/allowlist?caller=ai-core&amp;target=rag-db</code> \u2192 <code>{ operations: [...] }</code></li> <li>PUT <code>/admin/operator/allowlist</code> body <code>{ caller, target, operations: [] }</code> \u2192 <code>{ ok: true }</code></li> </ul>"},{"location":"policy/operator-allowlist/#ui","title":"UI","text":"<ul> <li>Admin Console \u2192 Plugin Dev Guide \u2192 \u201cGenerate Operator Allowlist\u201d to seed operations from a manifest.</li> </ul>"},{"location":"policy/operator-allowlist/#enforcement","title":"Enforcement","text":"<ul> <li>Core checks the allowlist in <code>/gateway/{target}/{operation}</code> before forwarding.</li> <li>Policy engine may also evaluate request context; all calls are audited.</li> </ul>"},{"location":"reference/cli/","title":"CLI Commands","text":"<p>CLI tooling and examples will be documented here.</p>"},{"location":"reference/env-vars/","title":"Environment Variables","text":"<p>Key environment variables and their defaults. See mkdocs nav for complete list to be expanded.</p>"},{"location":"reference/errors/","title":"Error Codes","text":"<p>List of common error codes and remediation tips.</p>"},{"location":"reference/glossary/","title":"Glossary","text":"<p>Vivified terminology and component glossary.</p>"},{"location":"security/authentication/","title":"Authentication","text":"<p>JWT-based auth with short-lived tokens, API keys for services, optional MFA and WebAuthn. See Admin Console \u2192 Settings \u2192 Security.</p>"},{"location":"security/authorization/","title":"Authorization","text":"<p>Trait-Based Access Control (TBAC) governs all sensitive actions. UI shows traits and blocked traits for transparency.</p>"},{"location":"security/encryption/","title":"Encryption","text":"<p>TLS in transit; encryption at rest via StorageService and external KMS where configured. Avoid plaintext secrets.</p>"},{"location":"security/hipaa/","title":"HIPAA Controls","text":"<p>Vivified aligns with HIPAA technical safeguards. This page will map specific controls to platform features. For pilots without PHI, you can skip hardening steps.</p>"}]}